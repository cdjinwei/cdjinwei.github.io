{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Jinwei Lei","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categorise","date":"2019-03-10T03:09:44.000Z","updated":"2019-03-10T07:51:41.710Z","comments":false,"path":"categorise/index.html","permalink":"http://yoursite.com/categorise/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-10T03:08:36.000Z","updated":"2019-03-10T07:51:41.711Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"GooglePlay会对apk重新签名","slug":"GooglePlay会对apk重新签名","date":"2019-03-10T08:17:24.000Z","updated":"2019-03-10T08:18:09.834Z","comments":true,"path":"2019/03/10/GooglePlay会对apk重新签名/","link":"","permalink":"http://yoursite.com/2019/03/10/GooglePlay会对apk重新签名/","excerpt":"","text":"上传到GooglePlay的Apk会被重新签名最近在准备发布新版本的时候,测试同学发现新版本的apk覆盖老版本的时候安装失败了,通过命令行安装发现问题 1Failure [INSTALL_FAILED_UPDATE_INCOMPATIBLE: Package your.package.name signatures do not match the previously installed version; ignoring!] 意思是两个版本的Apk签名不同,新版本的Apk能够确定是用release签名打包的,难道老版本的包是用了debug的签名吗?,经过排查老版本的包也是用的release签名,打包配置也都是同一套配置. 最后问题指向GooglePlay,应该是上传到GooglePlay后,被重新签名了,我将从googleplay下载的包卸载掉,安装本地的低版本,然后用高版本覆盖安装,果然没有问题,应该就是googleplay重新签名了,最后上传新包到googleplay成功上传,验证了猜想(因为签名如果不一致是不能上传成功的),最后发布更新可以正常更新","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"GooglePlay","slug":"GooglePlay","permalink":"http://yoursite.com/tags/GooglePlay/"},{"name":"apk签名","slug":"apk签名","permalink":"http://yoursite.com/tags/apk签名/"}]},{"title":"Android应用发布到GooglePlay","slug":"Android应用发布到GooglePlay","date":"2019-03-10T07:42:37.000Z","updated":"2019-03-10T07:51:41.709Z","comments":true,"path":"2019/03/10/Android应用发布到GooglePlay/","link":"","permalink":"http://yoursite.com/2019/03/10/Android应用发布到GooglePlay/","excerpt":"","text":"Android app发布到GooglePlay开头的废话: 最近使用cocoscreator开发的一个游戏的android版本需要发布到google play, 要上传到google play就需要再app中集成google play service, 以前本来接入过,接入过程非常简单,也有发布到google play的应用,结果时间长了居然给忘掉了,google了一下才配置好,所以索性将它记录下来,以免再忘 本文使用的是AndroidStudio的工程进行开发,文章也只是大致讲述在发布到googleplay上,程序配置上需要进行的工作 1. 配置build.gradle在app level下的build.gradle文件中加入google play service的依赖,不配置的话步骤2中的google_play_services_version就找不到定义123dependencies &#123; implementation &apos;com.google.android.gms:play-services:12.0.1&apos;&#125; 2. 配置AndroidManifest.xml12&lt;!-- google play --&gt;&lt;meta-data android:name=&quot;com.google.android.gms.version&quot; android:value=&quot;@integer/google_play_services_version&quot; /&gt; google_play_services_version不需要自己定义,它由google play service定义,它的值也随着google play service的版本变化而变化 上传apk至google play 必须加入这个配置,否则不能成功上传 配置到这里,就已经能够上传到google play了 3.跳转至GooglePlay商店app一般都有个引导评论的功能,android的app一般直接跳转到GooglePlay商店详情页面,用户可以在这里给app打分和评论,附上代码 1234567891011121314151617public static void launchAppDetail() &#123; final String GOOGLE_PLAY = &quot;com.android.vending&quot;;//这里对应的是谷歌商店，跳转别的商店改成对应的即可 try &#123; Uri uri = Uri.parse(&quot;market://details?id=&quot; + mActivity.getPackageName()); Intent intent = new Intent(Intent.ACTION_VIEW, uri); intent.setPackage(GOOGLE_PLAY); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); mActivity.startActivity(intent); &#125; catch (Exception e) &#123; mActivity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; Toast.makeText(mActivity, &quot;GooglePlay Store not exist&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"GooglePlay","slug":"GooglePlay","permalink":"http://yoursite.com/tags/GooglePlay/"}]},{"title":"Android工程集成Admob","slug":"Android工程集成Admob","date":"2019-03-10T06:14:36.000Z","updated":"2019-03-10T07:51:41.709Z","comments":true,"path":"2019/03/10/Android工程集成Admob/","link":"","permalink":"http://yoursite.com/2019/03/10/Android工程集成Admob/","excerpt":"","text":"AndroidStudio集成Admob前段时间公司的游戏开发的差不多了，集成了一些SDK，本次要说的就是其中之一的Admob，这个变现sdk就不用介绍了吧，看到这个文章的肯定都知道是什么，实在不清楚就去玩玩度娘。其实Android应用接入Admob没什么复杂的地方，只不过手上这个应用是CocosCreator开发的游戏，就是在一个Activity上面加了个GLView，然后渲染，要接入SDK需要稍微绕一点点弯路，然后国内的网络环境也堪忧，有可能会在测试的时候带来麻烦。 Android GL线程与UI线程通信熟悉Cocos的同学都知道，我们的游戏都是在一个GLview上进行的，游戏开发的语言是js，要想与UI线程通信，就需要引擎提供的api1jsb.reflection.callStaticMethod(&apos;类路径&apos;, &apos;方法名&apos;, &apos;参数签名&apos;, &apos;参数列表&apos;); 只有静态方法可以通过这个方式进行调用，关于这个方法的详细说明就不过多赘述，官方文档有很详细的讲解 [ 传送门 ]。 接入Admob依赖库首先在工程级的build.gradle中添加依赖(最外层的那个build.gralde文件)12345678allprojects &#123; repositories &#123; jcenter() maven &#123; url &quot;https://maven.google.com&quot; &#125; &#125;&#125; 再在app级的build.gradle中添加相关库的依赖(定义了applicationid等应用信息的那个build.gradle)1234dependencies &#123; //new dependence implementation &apos;com.google.android.gms:play-services-ads:15.0.0&apos;&#125; 到这里库的配置就弄完了，可以开始撸代码了 注意，Admob要求的Target Android API level 最低是14，不然编译阶段会提示你修改 接入Banner广告Banner广告就是一个显示在屏幕某个位置的横幅广告，难以避免地会占用游戏节目，是个很不友好的广告，在Android原生应用中，可以直接在要植入广告的界面的xml布局里面直接把banner广告布局填进去，适配也非常的简单，但是我这游戏就不行，cocos的长度单位与Android的不一样，需要经过一些换算才能得到正确的大小，Banner广告展示的大小，SDK有提供了很多尺寸的选择，其中Smart Banner是SDK自己进行适配，如果广告内容把游戏内容遮挡了，这肯定是非常不好的，所以我非常咸鱼的选择了最小的尺寸(快速迭代嘛，以后再优化 &gt;_&lt; )，下面直接贴代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546//首先初始化Admob mActivity就是游戏的主Activity，admob相关的id找让你接sdk的人要，嘻嘻MobileAds.initialize(mActivity,mActivity.getResources().getString(R.string.admob_appid));mActivity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; bannerAd = new AdView(mActivity); bannerAd.setAdUnitId(mActivity.getResources().getString(R.string.admob_banner_id)); bannerAd.setAdSize(AdSize.BANNER); bannerAd.setAdListener(bannerAdListener); AdRequest adRequest = new AdRequest.Builder() .addTestDevice(&quot;test_device_id&quot;) .build(); bannerAd.loadAd(adRequest); &#125; &#125;); public static AdListener bannerAdListener = new AdListener()&#123; @Override public void onAdLoaded() &#123; mActivity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; if(bannerAd.getParent() == null)&#123; FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT); params.gravity = Gravity.BOTTOM; mActivity.addContentView(bannerAd, params); &#125;else&#123; &#125; &#125; &#125;); &#125; @Override public void onAdFailedToLoad(final int errorCode) &#123; &#125; @Override public void onAdOpened() &#123; &#125; @Override public void onAdLeftApplication() &#123; &#125; @Override public void onAdClosed() &#123; &#125;); &#125; &#125;; 由于我们不能直接在GL thread去修改UI thread，所以我们这里用了个runOnUIthread包装了一下，也可以用其他方式去实现bannerAd.setAdListener(bannerAdListener) 是广告的生命周期的监听函数，广告的状态发生变化都会再这里得到通知，我这里在广告Load成功后对banner广告的UI进行了操作，如果Banner没有添加到Activity中就把它添加进去，并且把它放到了屏幕最底部，之所以加判断是因为Banner是会自己进行一定频率的刷新，如果每次Load成功都去添加一个到场景，老板知道了就要开除我了 接入插屏广告插屏广告·是一种完全覆盖游戏的广告，需要用户手动点击关闭按钮才会消失，这个的接入相比Banner就简单点了，由于产品要求要确保广告在某个时间点弹出来，所以插屏这里我预先进行了Load操作，然后在要展示的时候才show它，因为加载插屏是有一定的延迟的，如果广告内容是视频的话，延迟就更明显了，还是贴上代码123456789101112131415161718192021222324252627//加载插屏广告mActivity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; Log.e(DEBUG_TAG,&quot;loadInterstitial&quot;); AdRequest request = new AdRequest.Builder() .addTestDevice(&quot;test_device_id&quot;) .build(); interstitialAd.setAdListener(interstitialAdListener); interstitialAd.loadAd(request); &#125; &#125;);//展示插屏广告 //一定要确保在UI线程操作 mActivity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; if(interstitialAd.isLoaded())&#123; interstitialAd.show(); &#125;else if(interstitialAd.isLoading())&#123; &#125;else&#123; //如果没有loading，或者load失败了就进行load loadInterstitial(curInterstitialAdPos); &#125; &#125; &#125;); public static AdListener interstitialAdListener = new AdListener()&#123;&#125; 接入视频广告视频广告的接入和插屏几乎一样，非常简单，这次需要用到广告的回掉，因为这涉及到观看广告的奖励的发放, talk is cheap, show me the code~ 12345678910111213141516171819202122232425//load mActivity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; AdRequest adRequest = new AdRequest.Builder().build(); rewardedVideoAd.loadAd(mActivity.getResources().getString(R.string.admob_rewardedvideo_id),adRequest); &#125; &#125;);//showmActivity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; if(rewardedVideoAd.isLoaded())&#123; rewardedVideoAd.show(); &#125;else&#123; loadRewardedVideo(); &#125; &#125; &#125;);//广告回掉 //收到这个回掉表示用户完整观看了视频广告，需要发放奖励 @Override public void onRewarded(RewardItem rewardItem) &#123; Log.e(DEBUG_TAG,&quot;onRewarded&quot;); &#125; Always test with test ads ! 进行测试的时候尽量使用文档提供的测试id，一来可以排除掉市场人员app广告信息配置错误，二来这也是官方要求的(不要刷广告)，其实刷也没用，刷着刷着就不给你展示广告了 我为什么突然没广告看了！ 先别急，这一般不是我们程序员的问题(先甩锅),广告没有按预期播放一般有4个原因：1.INTERNAL_ERROR(内部错误) 2.INVALID_REQUEST(非法请求) 3.NETWORK_ERROR(网络错误) 4.NOT_FILL(未填充)所以测试的时候最好能把这些信息实时的输出出来，以便在没能成功展示广告时看到是什么原因（=_=） 有了AndroidStudio，接入广告真的简单了好多，其实还有原生广告和中介还么有说到，原生广告真的是非常的坑爹，这里简单说下中介，通过中介我们可以去接入一些其他的广告来源，目前文章中就能得到来自Admob的广告，通过一些配置就可以得到来自其他广告联盟的广告了，这两个就下次再写一篇讲讲","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"CocosCreator","slug":"CocosCreator","permalink":"http://yoursite.com/tags/CocosCreator/"},{"name":"Admob","slug":"Admob","permalink":"http://yoursite.com/tags/Admob/"}]}]}