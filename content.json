{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Jinwei Lei","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categorise","date":"2019-03-10T03:09:44.000Z","updated":"2019-03-10T07:51:41.710Z","comments":false,"path":"categorise/index.html","permalink":"http://yoursite.com/categorise/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-10T03:08:36.000Z","updated":"2019-03-10T07:51:41.711Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"寻路算法","slug":"SearchPath","date":"2019-07-07T14:09:52.000Z","updated":"2019-07-07T14:09:28.875Z","comments":true,"path":"2019/07/07/SearchPath/","link":"","permalink":"http://yoursite.com/2019/07/07/SearchPath/","excerpt":"","text":"A*寻路算法 A*寻路算是游戏开发中很常见的一种寻路算法，网络上相关的介绍也非常多，这次从其他寻路算法谈起，来看一看A星算法是如何诞生的，本文所有寻路算法使用TypeScript实现 算法默认权重不为负数 广度优先搜索广度优先搜索，就如同洪水一样，从搜索起点不断往外扩张 BreadthFirst 搜索实现 构建一个搜索队列searchList，列表中的节点就是等待搜索的节点，初始化时将起点加入到列表中; 构建一个searchRecord记录被搜索过的节点 从searchList搜索队列中取出一个节点，获取到该节点的临近节点(这里取上下左右4个节点)，若临近节点没有被搜索过，将临近节点加入到searchList中 重复步骤2，直到搜索完所有节点 提前结束上面的搜索步骤是地图中所有节点进行遍历，实际上寻路都存在一个或多个目标，当搜索到目标就可以停止算法，避免不必要的查询 关于searchRecordserachRecord用来记录搜索过的节点，当寻找到最终目标，最终的搜索路径就通过serachRecord构建出来, 我这里使用的是一个Dictionay来实现的，key是由节点的xy值构成的一个字符串，以表示一个唯一的节点，比如，当我们以(5,5)为起点，[(4, 5), (5, 4), (5, 6), (6, 5)]这四个点将会被搜索，那么searchReocrd的结构就是这样的123456searchRecord = &#123; &apos;4_5&apos;: Node(5, 5), &apos;5_4&apos;: Node(5, 5), &apos;5_6&apos;: Node(5, 5), &apos;6_5&apos;: Node(5, 5)&#125; 这样的结构表明了key与value的父子关系: (5, 5) -&gt; (4, 5), 当搜索继续下去，可能会出现下面的结果1234567searchRecord = &#123; &apos;4_5&apos;: Node(5, 5), &apos;3_5&apos;: Node(4, 5), &apos;2_5&apos;: Node(3, 5), &apos;1_5&apos;: Node(2, 5), ......&#125; 假如(1, 5)是我们的终点，那么根据searchRecord我们可以轻松构建出最终的搜索路径: (5, 5) -&gt; (4, 5) -&gt; (3, 5) -&gt; (2, 5) -&gt; (1, 5) 核心代码实现1234567891011121314151617181920let searchQueue: Array&lt;Node&gt; = [start];let searchRecord = &#123;&#125;searchRecord[start.toString()] = true;while(searchQueue.length)&#123; let current = searchQueue.shift(); //找到目标，终止搜索 if(current.toString() == end.toString())&#123; break; &#125; //获取搜索节点的所有邻居节点 let neighbors = this.getNeighbors(current); for(let node of neighbors)&#123; if(!searchRecord[node.toString()])&#123; searchQueue.push(node); //确定父子关系 searchRecord[node.toString()] = current; &#125; &#125;&#125; Dijkstra搜索通常在游戏中，角色在不同的环境，机动能力是不同的，角色通过一格平原可能花费1点行动力，通过山地就要花费3点，还有河流，冰川….. 在广度优先搜索中，searchList中的节点没有权重的概念，而Dijkstra算法在广度优先搜索的基础上加入了权重，权重高(游戏中可能表现为移动损耗低)的节点会优先进行搜索， 以寻找移动损耗更低的路径 搜索节点加权Dijkstra搜索中，每个节点都有一个权重值，代表着移动所需要的消耗，广度优先搜索其实也是特殊的Dijkstra搜索，所有的节点权重都是1 Dijkstra搜索 在上图中，以绿色点为起点进行搜索，首先将4个黄色的邻居节点加入到搜索列表中，他们以降序权重(值越小权重越高)在列表中排列：[1, 3, 4, 5]，下一轮搜索将取“1”节点进行搜索，重复上述的步骤，直到搜索结束 在算法中，新加入了一个Dictionary costRecord用来记录从起点到每一个节点的消耗，每个节点的消耗=父节点的消耗+节点的权重值; 如果节点已经搜索过，就不再搜索 优先级队列这里不能简单的使用广度优先搜索的list，在加入新的节点到searchList中时，我们需要对节点进行排序，搜索的时候直接从队头或队尾(取决于排序的升降序)取出节点进行搜索 如何保证最后的路径就是cost最低的路径？因为在搜索循环中，始终是先搜索cost最低的节点，最先抵达终点的路径必定是cost最低的路径 Dijkstra搜索示意图 上图中，箭头指向的节点表示是箭头所在的节点是被箭头指向的节点搜索到的，搜索的范围像洪水一样往外扩展，左上角由于被过高cost的节点阻挡，终止了搜索，searchRecord记录了所有搜索路径，因为是先搜索最低cost的节点，所以最先抵达终点的路径就是最低cost路径(试想一下，算法以最低代价进行搜索找到的节点，还会有另一条代价更低的路径到这个节点吗) 核心代码实现1234567891011121314151617181920212223let searchQueue: PriorityQueue = new PriorityQueue();let searchRecord = &#123;&#125;;let costRecord = &#123;&#125;;searchQueue.put(start, 0);searchRecord[start.toString()] = true;costRecord[start.toString()] = 0;while(searchQueue.length)&#123; let current = searchQueue.get(); if(current.getNode().toString() == end.toString())&#123; break; &#125; let neighbors = this.getNeighbors(current.node); for(let node of neighbors)&#123; let newCost = costRecord[current.node.toString()] + node.cost; if(costRecord[node.toString()] === undefined)&#123; searchRecord[node.toString()] = current.getNode(); costRecord[node.toString()] = newCost; searchQueue.put(node, newCost); &#125; &#125;&#125; 最佳优先搜索上面提到的两种算法，都是在不断的搜索地图里面的节点，当“碰巧”遇到了目标节点，才结束查询，期间有太多无意义的搜索; 而我们寻路是知道目标的方位的，查找的时候直接朝这个放下搜索不久可以省去多余的搜索了么，最佳优先搜索就是这么干的 以离目标的距离为优先级该算法计算每一个节点到终点的距离，优先搜索距离目标最近的节点，这样搜索就是朝着目标不断前进的 相比广度优先搜索算法，省去了大量的搜索 何如结算节点与目标的距离在我们的例子中，只有上下左右四个移动方向，使用曼哈顿距离最为合适，所谓曼哈顿距离，就是两个节点的x轴与y轴的距离之和123heuristics(start: Node, end: Node)&#123; return Math.abs(start.x - end.x) + Math.abs(start.y - end.y);&#125; 核心代码实现123456789101112131415161718let searchQueue: PriorityQueue = new PriorityQueue();let searchRecord = &#123;&#125;;searchQueue.put(start, this.heuristics(start, end));searchRecord[start.toString()] = true;while(searchQueue.length)&#123; let current = searchQueue.get(); if(current.getNode().toString() == end.toString())&#123; break; &#125; let neighbors = this.getNeighbors(current.node); for(let node of neighbors)&#123; if(!searchRecord[node.toString()])&#123; searchRecord[node.toString()] = current.getNode(); searchQueue.put(node, this.heuristics(node, end)); &#125; &#125;&#125; 最佳优先搜索的结果可能不是最短路径 在多个结点cost相同的情况下，上图是优先往上搜索，然而最佳优先搜索只是贪婪的朝目标前进，最后被障碍物挡住，只得向下绕行，所以本算法在存在障碍物的情况下(多数寻路都存在障碍物)，不能够保证是最短路径，想要高效的找到最短路径，就需要试试集各家之所长的A*算法了 A*搜索A*融合了最佳优先搜索和Dijkstra搜索的优点，同时使用节点移动权重和节点离终点的距离，对节点的搜索优先级进行评估有如下公式： F(x) = G(x) + H(x) F(x)为x节点的搜索权重，权重越小越先被搜索 G(x)为从起点移动到x节点的cost H(x)为从x节点到终点的距离 核心代码实现我们只需要对最佳搜索算法稍加改造1234567891011121314151617181920212223let searchQueue: PriorityQueue = new PriorityQueue();let searchRecord = &#123;&#125;;let costRecord = &#123;&#125;;searchRecord[start.toString()] = true;costRecord[start.toString()] = 0;searchQueue.put(start, this.heuristics(start, end) + costRecord[start.toString()]);while(searchQueue.length)&#123; let current = searchQueue.get(); if(current.getNode().toString() == end.toString())&#123; break; &#125; let neighbors = this.getNeighbors(current.getNode()); for(let node of neighbors)&#123; let newCost = node.cost + costRecord[current.getNode().toString()]; if(costRecord[node.toString()] === undefined)&#123; costRecord[node.toString()] = newCost; searchRecord[node.toString()] = current.getNode(); //节点的搜索优先级将由cost和离终点距离决定 searchQueue.put(node, newCost + this.heuristics(node, end)); &#125; &#125;&#125; 各个算法的对比A*算法 A*算法 最佳优先算法 最佳优先算法 Dijkstra算法 Dijkstra算法 广度优先算法 广度优先算法 最后本文只是简单讲述了一下AStar是怎样演变而来的，使用的Astar算法也是非常原始，现在Astar算法也在不断的变化，出现了很多优化版本，有兴趣深入研究的可以直接在网络上查询 寻路测试demo源码地址：https://github.com/cdjinwei/SearchPath 参考文章：https://www.redblobgames.com/pathfinding/a-star/introduction.html 在线可视寻路工具：http://qiao.github.io/PathFinding.js/visual/","categories":[],"tags":[{"name":"CocosCreator","slug":"CocosCreator","permalink":"http://yoursite.com/tags/CocosCreator/"},{"name":"A*","slug":"A","permalink":"http://yoursite.com/tags/A/"},{"name":"寻路算法","slug":"寻路算法","permalink":"http://yoursite.com/tags/寻路算法/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://yoursite.com/tags/Dijkstra/"},{"name":"广度优先搜索","slug":"广度优先搜索","permalink":"http://yoursite.com/tags/广度优先搜索/"},{"name":"最佳优先搜索","slug":"最佳优先搜索","permalink":"http://yoursite.com/tags/最佳优先搜索/"}]},{"title":"CocosCreator资源加载和释放","slug":"CocosCreator资源加载和释放","date":"2019-05-29T15:37:06.000Z","updated":"2019-06-05T16:12:21.545Z","comments":true,"path":"2019/05/29/CocosCreator资源加载和释放/","link":"","permalink":"http://yoursite.com/2019/05/29/CocosCreator资源加载和释放/","excerpt":"","text":"CocosCreator资源加载和释放 CocosCreator的官方文档对资源的加载和释放方面描述的不算清楚, 不少人对游戏内存的把控没有信心,今天我就来捋一捋CocosCreator的资源加载和释放,权当是测试一下各个资源加载和释放的接口 本文基于CocosCreator2.1.1 0. CocosCreator的resources目录使用过CocosCreator的人应该都知道,resorces目录是用来存放那些需要再游戏中动态加载的资源, 官方稳定建议如果资源不需要动态加载,就不要放在该目录下. 经测试, resources目录下的所有资源在构建工程后生成的setting.js文件中有记录,resources目录下的资源越多也就意味着setting.js越大 1. CocosCreator的各种类型的资源在CocosCreator2.1.1版本中,在空场景的情况下cc.loader._cache中一共有20个对象,下文的资源加载和释放的对比将会刨除这20个对象 (1) cc.Texture2D这是一个基本的图片资源类型,很多游戏都有这个12345//加载一个cc.Texture2D类型的资源cc.loader.loadRes(&apos;pic&apos;, cc.Texture2D, (err, data) =&gt; &#123; if(err) return console.log(err); console.log(cc.loader._cache);&#125;); 以上代码加载完成之后,_cache中多了一个png资源和一个json资源,其中png资源是图片资源是占用内存的大头, 而json资源则代表着一个cc.Texture2D资源对象.在cache中,cc.Texture2D对象是以json文件的名字作为key保存的,单独释放_cache中的png对象,内存并没有明显下降,图片占用的内存明显没有被释放掉,而单独释放json的结果是png和json都被释放掉了,内存也有明显的下降,所以加载了那些资源就来,释放时就要完完全全把那些资源释放掉 单独释放png, json文件没有被一起释放,内存也没有明显降低 1cc.loader.release(&apos;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.png&apos;); 单独释放json, png和json都被释放了,内存有明显下降 1cc.loader.release(&apos;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.json&apos;); 那么问题来了,怎样知道加载一个cc.Texture2D时还加载了写什么进来呢?cc.loader.getDependsRecursively()可以获取传入对象的所有依赖资源,参数类型为cc.Asset,cc.RawAsset,或者string cc.Asset: 在 Creator 中，所有继承自 cc.Asset 的类型都统称资源，如 cc.Texture2D, cc.SpriteFrame, cc.AnimationClip, cc.Prefab 等。它们的加载是统一并且自动化的，相互依赖的资源能够被自动预加载(2.0版本文档原文)cc.RawAsset: Creator似乎准备把cc.Asset和cc.RawAsset的标准统一起来,在2.0的文档中没有找到cc.RawAsset的说明,应该已经统一了string: 这里就是资源的路径12345678910111213141516cc.loader.loadRes(&apos;image&apos;, cc.Texture2D, (err, data) =&gt; &#123; //data 就是一个Texture2D对象 let deps = cc.loader.getDependsRecursively(data); console.log(deps);&#125;);//deps的输出, 就是加载image时,所加载的所有资源[&quot;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.png&quot;,&quot;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.json&quot;]//通过资源的路径也能获取到资源的依赖//获取到的是//[&apos;8fdd1c3c-1ec9-4018-b57b-551c9b37eba4&apos;]let deps = cc.loader.getDependsRecursively(&apos;image&apos;);//这样也能将加载image时所加载的资源全部释放掉cc.loader.release(deps); (1) cc.SpriteFrameSpriteFrame类似于一个中间件,夹在Texture2D和Sprite之间,当我们以cc.SpriteFrame类型进行资源加载时,我们会得到一个SpriteFrame对象,而通过SpriteFrame对象,我们能够获取到3个依赖资源12345678910cc.loader.loadRes(&apos;image&apos;, cc.SpriteFrame, (err, data) =&gt; &#123; //data 就是一个SpriteFrame对象 let desp = cc.loader.getDependsRecursively(data); console.log(desp);&#125;);//desp的输出, 就是加载image时,所加载的所有资源[&quot;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.png&quot;,&quot;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.json&quot;,res/import/3e/3e24d7c4-3041-4acd-bc91-378df4a24e5f.json] 前两个资源是我们以cc.Texture2D类型进行加载得到的,第三个资源就代表着我们的SpriteFrame对象,这个SpriteFrame对象在_cache中,就是以这个json文件的名字作为key进行保存的 在释放以Texture2D类型加载进来的资源时, cc.loader.release(‘image’)能够轻松将加载进来的资源释放掉,而想要释放以SpriteFrame类型加载进来的资源,这么简单的处理将会坑到自己那是因为从资源路径获取到的依赖资源不包含SpriteFrame, 如果这样鲁莽释放,加载进来的SpriteFrame就残留在了cache中,当我们再次以SpriteFrame类型加载这个资源时,由于cache中残留的SpriteFrame对象,loader将不会加载资源,而是直接返回了cache中这个已经丢失了Texture2D的SpriteFrame,我们此时可以在控制台中看到一大片的webgl的警告 2. 如何优雅地释放资源资源引用计数对于释放动态加载的资源,有些人的做法是在加载时获取到加载资源的完整依赖进行累加计数,在释放时对对应资源减一,引用为0时进行真正的释放 资源份文件夹管理另一种做法是把各个界面和场景自己才会用到的资源分文件夹管理,然后通用资源用另一个文件夹管理,在游戏离开某个界面进入另一个界面时,将除通用资源以外的资源统统释放掉 我个人目前还是跟喜欢后一种做法,一个原因是自己没有一个好的引用计数的实现,另一个原因是经常用到的资源可能会时不时被释放掉,而再次加载有需要一定的时间,会造成不好的体验,就使用了后一种做法","categories":[],"tags":[]},{"title":"CocosCreatorWeb调试模拟IphoneX","slug":"CocosCreatorWeb调试模拟IphoneX","date":"2019-03-19T14:09:11.000Z","updated":"2019-03-19T14:50:43.821Z","comments":true,"path":"2019/03/19/CocosCreatorWeb调试模拟IphoneX/","link":"","permalink":"http://yoursite.com/2019/03/19/CocosCreatorWeb调试模拟IphoneX/","excerpt":"","text":"CocosCreatorWeb调试模拟IphoneXCocosCreator的web调试工具，默认提供了模拟多种设备分辨率的选项，但通常开发者都会有特殊的适配需求(适配iphonex等刘海屏)，CocosCreator并没有涵盖到也很难涵盖到各种分辨率，不过开发者可以自行添加 CocosCreator默认提供的选项 设置自定义分辨率在CocosCreator\\resources\\static\\preview-templates下的boot.js中有分辨率模拟选项的配置12345678910111213141516// init device resolutions var devices = [ &#123; name: &apos;Apple iPad&apos;, width: 1024, height: 768, ratio: 2 &#125;, &#123; name: &apos;Apple iPad Mini&apos;, width: 1024, height: 768, ratio: 1 &#125;, &#123; name: &apos;Apple iPhone 4&apos;, width: 320, height: 480, ratio: 2 &#125;, &#123; name: &apos;Apple iPhone 5&apos;, width: 320, height: 568, ratio: 2 &#125;, &#123; name: &apos;Apple iPhone 6&apos;, width: 375, height: 667, ratio: 2 &#125;, &#123; name: &apos;Apple iPhone 6 Plus&apos;, width: 414, height: 736, ratio: 3 &#125;, &#123; name: &apos;Huawei P9&apos;, width: 540, height: 960, ratio: 2&#125;, &#123; name: &apos;Huawei Mate9 Pro&apos;, width: 720, height: 1280, ratio: 2&#125;, &#123; name: &apos;Goolge Nexus 4&apos;, width: 384, height: 640, ratio: 2 &#125;, &#123; name: &apos;Goolge Nexus 5&apos;, width: 360, height: 640, ratio: 3 &#125;, &#123; name: &apos;Goolge Nexus 6&apos;, width: 412, height: 732, ratio: 3.5 &#125;, &#123; name: &apos;Goolge Nexus 7&apos;, width: 960, height: 600, ratio: 2 &#125;, &#123; name: &apos;Iphone X&apos;, width: 375, height: 812, ratio: 3 &#125;, ]; 只需要按照已有的格式添加就可以了 name：模拟器选项中展示的名字 width：模拟器在网页上实际的宽度 height：模拟器在网页上实际的高度 ratio：字面意思是缩放比例，但是修改过后没有产生效果？我在devices中加入了iphonex的分辨率信息1&#123; name: &apos;Iphone X&apos;, width: 1125, height: 2436, ratio: 1 &#125; 预览后发现游戏画面已经超过了浏览器窗口的大小，出现了滑动条，所以将宽高缩小3倍1&#123; name: &apos;Iphone X&apos;, width: 375, height: 812, ratio: 3 &#125;, 刷新页面得到了能够正常预览的大小 IphoneXWeb模拟器 虽然web模拟器调试非常便利，但是适配IphoneX还是要以实机效果为准","categories":[],"tags":[{"name":"CocosCreator","slug":"CocosCreator","permalink":"http://yoursite.com/tags/CocosCreator/"}]},{"title":"GooglePlay会对apk重新签名","slug":"GooglePlay会对apk重新签名","date":"2019-03-10T08:17:24.000Z","updated":"2019-03-10T08:18:09.834Z","comments":true,"path":"2019/03/10/GooglePlay会对apk重新签名/","link":"","permalink":"http://yoursite.com/2019/03/10/GooglePlay会对apk重新签名/","excerpt":"","text":"上传到GooglePlay的Apk会被重新签名最近在准备发布新版本的时候,测试同学发现新版本的apk覆盖老版本的时候安装失败了,通过命令行安装发现问题 1Failure [INSTALL_FAILED_UPDATE_INCOMPATIBLE: Package your.package.name signatures do not match the previously installed version; ignoring!] 意思是两个版本的Apk签名不同,新版本的Apk能够确定是用release签名打包的,难道老版本的包是用了debug的签名吗?,经过排查老版本的包也是用的release签名,打包配置也都是同一套配置. 最后问题指向GooglePlay,应该是上传到GooglePlay后,被重新签名了,我将从googleplay下载的包卸载掉,安装本地的低版本,然后用高版本覆盖安装,果然没有问题,应该就是googleplay重新签名了,最后上传新包到googleplay成功上传,验证了猜想(因为签名如果不一致是不能上传成功的),最后发布更新可以正常更新","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"GooglePlay","slug":"GooglePlay","permalink":"http://yoursite.com/tags/GooglePlay/"},{"name":"apk签名","slug":"apk签名","permalink":"http://yoursite.com/tags/apk签名/"}]},{"title":"Android应用发布到GooglePlay","slug":"AndroidPublishToGooglePlay","date":"2019-03-10T07:42:37.000Z","updated":"2019-03-19T14:05:02.728Z","comments":true,"path":"2019/03/10/AndroidPublishToGooglePlay/","link":"","permalink":"http://yoursite.com/2019/03/10/AndroidPublishToGooglePlay/","excerpt":"","text":"Android app发布到GooglePlay开头的废话: 最近使用cocoscreator开发的一个游戏的android版本需要发布到google play, 要上传到google play就需要再app中集成google play service, 以前本来接入过,接入过程非常简单,也有发布到google play的应用,结果时间长了居然给忘掉了,google了一下才配置好,所以索性将它记录下来,以免再忘 本文使用的是AndroidStudio的工程进行开发,文章也只是大致讲述在发布到googleplay上,程序配置上需要进行的工作 1. 配置build.gradle在app level下的build.gradle文件中加入google play service的依赖,不配置的话步骤2中的google_play_services_version就找不到定义123dependencies &#123; implementation &apos;com.google.android.gms:play-services:12.0.1&apos;&#125; 2. 配置AndroidManifest.xml12&lt;!-- google play --&gt;&lt;meta-data android:name=&quot;com.google.android.gms.version&quot; android:value=&quot;@integer/google_play_services_version&quot; /&gt; google_play_services_version不需要自己定义,它由google play service定义,它的值也随着google play service的版本变化而变化 上传apk至google play 必须加入这个配置,否则不能成功上传 配置到这里,就已经能够上传到google play了 3.跳转至GooglePlay商店app一般都有个引导评论的功能,android的app一般直接跳转到GooglePlay商店详情页面,用户可以在这里给app打分和评论,附上代码 1234567891011121314151617public static void launchAppDetail() &#123; final String GOOGLE_PLAY = &quot;com.android.vending&quot;;//这里对应的是谷歌商店，跳转别的商店改成对应的即可 try &#123; Uri uri = Uri.parse(&quot;market://details?id=&quot; + mActivity.getPackageName()); Intent intent = new Intent(Intent.ACTION_VIEW, uri); intent.setPackage(GOOGLE_PLAY); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); mActivity.startActivity(intent); &#125; catch (Exception e) &#123; mActivity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; Toast.makeText(mActivity, &quot;GooglePlay Store not exist&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"GooglePlay","slug":"GooglePlay","permalink":"http://yoursite.com/tags/GooglePlay/"}]},{"title":"Android工程集成Admob","slug":"AndroidIntegrateAdmob","date":"2019-03-10T06:14:36.000Z","updated":"2019-03-19T14:04:46.809Z","comments":true,"path":"2019/03/10/AndroidIntegrateAdmob/","link":"","permalink":"http://yoursite.com/2019/03/10/AndroidIntegrateAdmob/","excerpt":"","text":"AndroidStudio集成Admob前段时间公司的游戏开发的差不多了，集成了一些SDK，本次要说的就是其中之一的Admob，这个变现sdk就不用介绍了吧，看到这个文章的肯定都知道是什么，实在不清楚就去玩玩度娘。其实Android应用接入Admob没什么复杂的地方，只不过手上这个应用是CocosCreator开发的游戏，就是在一个Activity上面加了个GLView，然后渲染，要接入SDK需要稍微绕一点点弯路，然后国内的网络环境也堪忧，有可能会在测试的时候带来麻烦。 Android GL线程与UI线程通信熟悉Cocos的同学都知道，我们的游戏都是在一个GLview上进行的，游戏开发的语言是js，要想与UI线程通信，就需要引擎提供的api1jsb.reflection.callStaticMethod(&apos;类路径&apos;, &apos;方法名&apos;, &apos;参数签名&apos;, &apos;参数列表&apos;); 只有静态方法可以通过这个方式进行调用，关于这个方法的详细说明就不过多赘述，官方文档有很详细的讲解 [ 传送门 ]。 接入Admob依赖库首先在工程级的build.gradle中添加依赖(最外层的那个build.gralde文件)12345678allprojects &#123; repositories &#123; jcenter() maven &#123; url &quot;https://maven.google.com&quot; &#125; &#125;&#125; 再在app级的build.gradle中添加相关库的依赖(定义了applicationid等应用信息的那个build.gradle)1234dependencies &#123; //new dependence implementation &apos;com.google.android.gms:play-services-ads:15.0.0&apos;&#125; 到这里库的配置就弄完了，可以开始撸代码了 注意，Admob要求的Target Android API level 最低是14，不然编译阶段会提示你修改 接入Banner广告Banner广告就是一个显示在屏幕某个位置的横幅广告，难以避免地会占用游戏节目，是个很不友好的广告，在Android原生应用中，可以直接在要植入广告的界面的xml布局里面直接把banner广告布局填进去，适配也非常的简单，但是我这游戏就不行，cocos的长度单位与Android的不一样，需要经过一些换算才能得到正确的大小，Banner广告展示的大小，SDK有提供了很多尺寸的选择，其中Smart Banner是SDK自己进行适配，如果广告内容把游戏内容遮挡了，这肯定是非常不好的，所以我非常咸鱼的选择了最小的尺寸(快速迭代嘛，以后再优化 &gt;_&lt; )，下面直接贴代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546//首先初始化Admob mActivity就是游戏的主Activity，admob相关的id找让你接sdk的人要，嘻嘻MobileAds.initialize(mActivity,mActivity.getResources().getString(R.string.admob_appid));mActivity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; bannerAd = new AdView(mActivity); bannerAd.setAdUnitId(mActivity.getResources().getString(R.string.admob_banner_id)); bannerAd.setAdSize(AdSize.BANNER); bannerAd.setAdListener(bannerAdListener); AdRequest adRequest = new AdRequest.Builder() .addTestDevice(&quot;test_device_id&quot;) .build(); bannerAd.loadAd(adRequest); &#125; &#125;); public static AdListener bannerAdListener = new AdListener()&#123; @Override public void onAdLoaded() &#123; mActivity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; if(bannerAd.getParent() == null)&#123; FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT); params.gravity = Gravity.BOTTOM; mActivity.addContentView(bannerAd, params); &#125;else&#123; &#125; &#125; &#125;); &#125; @Override public void onAdFailedToLoad(final int errorCode) &#123; &#125; @Override public void onAdOpened() &#123; &#125; @Override public void onAdLeftApplication() &#123; &#125; @Override public void onAdClosed() &#123; &#125;); &#125; &#125;; 由于我们不能直接在GL thread去修改UI thread，所以我们这里用了个runOnUIthread包装了一下，也可以用其他方式去实现bannerAd.setAdListener(bannerAdListener) 是广告的生命周期的监听函数，广告的状态发生变化都会再这里得到通知，我这里在广告Load成功后对banner广告的UI进行了操作，如果Banner没有添加到Activity中就把它添加进去，并且把它放到了屏幕最底部，之所以加判断是因为Banner是会自己进行一定频率的刷新，如果每次Load成功都去添加一个到场景，老板知道了就要开除我了 接入插屏广告插屏广告·是一种完全覆盖游戏的广告，需要用户手动点击关闭按钮才会消失，这个的接入相比Banner就简单点了，由于产品要求要确保广告在某个时间点弹出来，所以插屏这里我预先进行了Load操作，然后在要展示的时候才show它，因为加载插屏是有一定的延迟的，如果广告内容是视频的话，延迟就更明显了，还是贴上代码123456789101112131415161718192021222324252627//加载插屏广告mActivity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; Log.e(DEBUG_TAG,&quot;loadInterstitial&quot;); AdRequest request = new AdRequest.Builder() .addTestDevice(&quot;test_device_id&quot;) .build(); interstitialAd.setAdListener(interstitialAdListener); interstitialAd.loadAd(request); &#125; &#125;);//展示插屏广告 //一定要确保在UI线程操作 mActivity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; if(interstitialAd.isLoaded())&#123; interstitialAd.show(); &#125;else if(interstitialAd.isLoading())&#123; &#125;else&#123; //如果没有loading，或者load失败了就进行load loadInterstitial(curInterstitialAdPos); &#125; &#125; &#125;); public static AdListener interstitialAdListener = new AdListener()&#123;&#125; 接入视频广告视频广告的接入和插屏几乎一样，非常简单，这次需要用到广告的回掉，因为这涉及到观看广告的奖励的发放, talk is cheap, show me the code~ 12345678910111213141516171819202122232425//load mActivity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; AdRequest adRequest = new AdRequest.Builder().build(); rewardedVideoAd.loadAd(mActivity.getResources().getString(R.string.admob_rewardedvideo_id),adRequest); &#125; &#125;);//showmActivity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; if(rewardedVideoAd.isLoaded())&#123; rewardedVideoAd.show(); &#125;else&#123; loadRewardedVideo(); &#125; &#125; &#125;);//广告回掉 //收到这个回掉表示用户完整观看了视频广告，需要发放奖励 @Override public void onRewarded(RewardItem rewardItem) &#123; Log.e(DEBUG_TAG,&quot;onRewarded&quot;); &#125; Always test with test ads ! 进行测试的时候尽量使用文档提供的测试id，一来可以排除掉市场人员app广告信息配置错误，二来这也是官方要求的(不要刷广告)，其实刷也没用，刷着刷着就不给你展示广告了 我为什么突然没广告看了！ 先别急，这一般不是我们程序员的问题(先甩锅),广告没有按预期播放一般有4个原因：1.INTERNAL_ERROR(内部错误) 2.INVALID_REQUEST(非法请求) 3.NETWORK_ERROR(网络错误) 4.NOT_FILL(未填充)所以测试的时候最好能把这些信息实时的输出出来，以便在没能成功展示广告时看到是什么原因（=_=） 有了AndroidStudio，接入广告真的简单了好多，其实还有原生广告和中介还么有说到，原生广告真的是非常的坑爹，这里简单说下中介，通过中介我们可以去接入一些其他的广告来源，目前文章中就能得到来自Admob的广告，通过一些配置就可以得到来自其他广告联盟的广告了，这两个就下次再写一篇讲讲","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"CocosCreator","slug":"CocosCreator","permalink":"http://yoursite.com/tags/CocosCreator/"},{"name":"Admob","slug":"Admob","permalink":"http://yoursite.com/tags/Admob/"}]}]}