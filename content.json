{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Jinwei Lei","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categorise","date":"2019-03-10T03:09:44.000Z","updated":"2019-03-10T07:51:41.710Z","comments":false,"path":"categorise/index.html","permalink":"http://yoursite.com/categorise/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-10T03:08:36.000Z","updated":"2019-03-10T07:51:41.711Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CocosCreator资源加载和释放","slug":"CocosCreator资源加载和释放","date":"2019-05-29T15:37:06.000Z","updated":"2019-06-05T16:12:21.545Z","comments":true,"path":"2019/05/29/CocosCreator资源加载和释放/","link":"","permalink":"http://yoursite.com/2019/05/29/CocosCreator资源加载和释放/","excerpt":"","text":"CocosCreator资源加载和释放 CocosCreator的官方文档对资源的加载和释放方面描述的不算清楚, 不少人对游戏内存的把控没有信心,今天我就来捋一捋CocosCreator的资源加载和释放,权当是测试一下各个资源加载和释放的接口 本文基于CocosCreator2.1.1 0. CocosCreator的resources目录使用过CocosCreator的人应该都知道,resorces目录是用来存放那些需要再游戏中动态加载的资源, 官方稳定建议如果资源不需要动态加载,就不要放在该目录下. 经测试, resources目录下的所有资源在构建工程后生成的setting.js文件中有记录,resources目录下的资源越多也就意味着setting.js越大 1. CocosCreator的各种类型的资源在CocosCreator2.1.1版本中,在空场景的情况下cc.loader._cache中一共有20个对象,下文的资源加载和释放的对比将会刨除这20个对象 (1) cc.Texture2D这是一个基本的图片资源类型,很多游戏都有这个12345//加载一个cc.Texture2D类型的资源cc.loader.loadRes(&apos;pic&apos;, cc.Texture2D, (err, data) =&gt; &#123; if(err) return console.log(err); console.log(cc.loader._cache);&#125;); 以上代码加载完成之后,_cache中多了一个png资源和一个json资源,其中png资源是图片资源是占用内存的大头, 而json资源则代表着一个cc.Texture2D资源对象.在cache中,cc.Texture2D对象是以json文件的名字作为key保存的,单独释放_cache中的png对象,内存并没有明显下降,图片占用的内存明显没有被释放掉,而单独释放json的结果是png和json都被释放掉了,内存也有明显的下降,所以加载了那些资源就来,释放时就要完完全全把那些资源释放掉 单独释放png, json文件没有被一起释放,内存也没有明显降低 1cc.loader.release(&apos;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.png&apos;); 单独释放json, png和json都被释放了,内存有明显下降 1cc.loader.release(&apos;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.json&apos;); 那么问题来了,怎样知道加载一个cc.Texture2D时还加载了写什么进来呢?cc.loader.getDependsRecursively()可以获取传入对象的所有依赖资源,参数类型为cc.Asset,cc.RawAsset,或者string cc.Asset: 在 Creator 中，所有继承自 cc.Asset 的类型都统称资源，如 cc.Texture2D, cc.SpriteFrame, cc.AnimationClip, cc.Prefab 等。它们的加载是统一并且自动化的，相互依赖的资源能够被自动预加载(2.0版本文档原文)cc.RawAsset: Creator似乎准备把cc.Asset和cc.RawAsset的标准统一起来,在2.0的文档中没有找到cc.RawAsset的说明,应该已经统一了string: 这里就是资源的路径12345678910111213141516cc.loader.loadRes(&apos;image&apos;, cc.Texture2D, (err, data) =&gt; &#123; //data 就是一个Texture2D对象 let deps = cc.loader.getDependsRecursively(data); console.log(deps);&#125;);//deps的输出, 就是加载image时,所加载的所有资源[&quot;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.png&quot;,&quot;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.json&quot;]//通过资源的路径也能获取到资源的依赖//获取到的是//[&apos;8fdd1c3c-1ec9-4018-b57b-551c9b37eba4&apos;]let deps = cc.loader.getDependsRecursively(&apos;image&apos;);//这样也能将加载image时所加载的资源全部释放掉cc.loader.release(deps); (1) cc.SpriteFrameSpriteFrame类似于一个中间件,夹在Texture2D和Sprite之间,当我们以cc.SpriteFrame类型进行资源加载时,我们会得到一个SpriteFrame对象,而通过SpriteFrame对象,我们能够获取到3个依赖资源12345678910cc.loader.loadRes(&apos;image&apos;, cc.SpriteFrame, (err, data) =&gt; &#123; //data 就是一个SpriteFrame对象 let desp = cc.loader.getDependsRecursively(data); console.log(desp);&#125;);//desp的输出, 就是加载image时,所加载的所有资源[&quot;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.png&quot;,&quot;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.json&quot;,res/import/3e/3e24d7c4-3041-4acd-bc91-378df4a24e5f.json] 前两个资源是我们以cc.Texture2D类型进行加载得到的,第三个资源就代表着我们的SpriteFrame对象,这个SpriteFrame对象在_cache中,就是以这个json文件的名字作为key进行保存的 在释放以Texture2D类型加载进来的资源时, cc.loader.release(‘image’)能够轻松将加载进来的资源释放掉,而想要释放以SpriteFrame类型加载进来的资源,这么简单的处理将会坑到自己那是因为从资源路径获取到的依赖资源不包含SpriteFrame, 如果这样鲁莽释放,加载进来的SpriteFrame就残留在了cache中,当我们再次以SpriteFrame类型加载这个资源时,由于cache中残留的SpriteFrame对象,loader将不会加载资源,而是直接返回了cache中这个已经丢失了Texture2D的SpriteFrame,我们此时可以在控制台中看到一大片的webgl的警告 2. 如何优雅地释放资源资源引用计数对于释放动态加载的资源,有些人的做法是在加载时获取到加载资源的完整依赖进行累加计数,在释放时对对应资源减一,引用为0时进行真正的释放 资源份文件夹管理另一种做法是把各个界面和场景自己才会用到的资源分文件夹管理,然后通用资源用另一个文件夹管理,在游戏离开某个界面进入另一个界面时,将除通用资源以外的资源统统释放掉 我个人目前还是跟喜欢后一种做法,一个原因是自己没有一个好的引用计数的实现,另一个原因是经常用到的资源可能会时不时被释放掉,而再次加载有需要一定的时间,会造成不好的体验,就使用了后一种做法","categories":[],"tags":[]},{"title":"CocosCreatorWeb调试模拟IphoneX","slug":"CocosCreatorWeb调试模拟IphoneX","date":"2019-03-19T14:09:11.000Z","updated":"2019-03-19T14:50:43.821Z","comments":true,"path":"2019/03/19/CocosCreatorWeb调试模拟IphoneX/","link":"","permalink":"http://yoursite.com/2019/03/19/CocosCreatorWeb调试模拟IphoneX/","excerpt":"","text":"CocosCreatorWeb调试模拟IphoneXCocosCreator的web调试工具，默认提供了模拟多种设备分辨率的选项，但通常开发者都会有特殊的适配需求(适配iphonex等刘海屏)，CocosCreator并没有涵盖到也很难涵盖到各种分辨率，不过开发者可以自行添加 CocosCreator默认提供的选项 设置自定义分辨率在CocosCreator\\resources\\static\\preview-templates下的boot.js中有分辨率模拟选项的配置12345678910111213141516// init device resolutions var devices = [ &#123; name: &apos;Apple iPad&apos;, width: 1024, height: 768, ratio: 2 &#125;, &#123; name: &apos;Apple iPad Mini&apos;, width: 1024, height: 768, ratio: 1 &#125;, &#123; name: &apos;Apple iPhone 4&apos;, width: 320, height: 480, ratio: 2 &#125;, &#123; name: &apos;Apple iPhone 5&apos;, width: 320, height: 568, ratio: 2 &#125;, &#123; name: &apos;Apple iPhone 6&apos;, width: 375, height: 667, ratio: 2 &#125;, &#123; name: &apos;Apple iPhone 6 Plus&apos;, width: 414, height: 736, ratio: 3 &#125;, &#123; name: &apos;Huawei P9&apos;, width: 540, height: 960, ratio: 2&#125;, &#123; name: &apos;Huawei Mate9 Pro&apos;, width: 720, height: 1280, ratio: 2&#125;, &#123; name: &apos;Goolge Nexus 4&apos;, width: 384, height: 640, ratio: 2 &#125;, &#123; name: &apos;Goolge Nexus 5&apos;, width: 360, height: 640, ratio: 3 &#125;, &#123; name: &apos;Goolge Nexus 6&apos;, width: 412, height: 732, ratio: 3.5 &#125;, &#123; name: &apos;Goolge Nexus 7&apos;, width: 960, height: 600, ratio: 2 &#125;, &#123; name: &apos;Iphone X&apos;, width: 375, height: 812, ratio: 3 &#125;, ]; 只需要按照已有的格式添加就可以了 name：模拟器选项中展示的名字 width：模拟器在网页上实际的宽度 height：模拟器在网页上实际的高度 ratio：字面意思是缩放比例，但是修改过后没有产生效果？我在devices中加入了iphonex的分辨率信息1&#123; name: &apos;Iphone X&apos;, width: 1125, height: 2436, ratio: 1 &#125; 预览后发现游戏画面已经超过了浏览器窗口的大小，出现了滑动条，所以将宽高缩小3倍1&#123; name: &apos;Iphone X&apos;, width: 375, height: 812, ratio: 3 &#125;, 刷新页面得到了能够正常预览的大小 IphoneXWeb模拟器 虽然web模拟器调试非常便利，但是适配IphoneX还是要以实机效果为准","categories":[],"tags":[{"name":"CocosCreator","slug":"CocosCreator","permalink":"http://yoursite.com/tags/CocosCreator/"}]},{"title":"GooglePlay会对apk重新签名","slug":"GooglePlay会对apk重新签名","date":"2019-03-10T08:17:24.000Z","updated":"2019-03-10T08:18:09.834Z","comments":true,"path":"2019/03/10/GooglePlay会对apk重新签名/","link":"","permalink":"http://yoursite.com/2019/03/10/GooglePlay会对apk重新签名/","excerpt":"","text":"上传到GooglePlay的Apk会被重新签名最近在准备发布新版本的时候,测试同学发现新版本的apk覆盖老版本的时候安装失败了,通过命令行安装发现问题 1Failure [INSTALL_FAILED_UPDATE_INCOMPATIBLE: Package your.package.name signatures do not match the previously installed version; ignoring!] 意思是两个版本的Apk签名不同,新版本的Apk能够确定是用release签名打包的,难道老版本的包是用了debug的签名吗?,经过排查老版本的包也是用的release签名,打包配置也都是同一套配置. 最后问题指向GooglePlay,应该是上传到GooglePlay后,被重新签名了,我将从googleplay下载的包卸载掉,安装本地的低版本,然后用高版本覆盖安装,果然没有问题,应该就是googleplay重新签名了,最后上传新包到googleplay成功上传,验证了猜想(因为签名如果不一致是不能上传成功的),最后发布更新可以正常更新","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"GooglePlay","slug":"GooglePlay","permalink":"http://yoursite.com/tags/GooglePlay/"},{"name":"apk签名","slug":"apk签名","permalink":"http://yoursite.com/tags/apk签名/"}]},{"title":"Android应用发布到GooglePlay","slug":"AndroidPublishToGooglePlay","date":"2019-03-10T07:42:37.000Z","updated":"2019-03-19T14:05:02.728Z","comments":true,"path":"2019/03/10/AndroidPublishToGooglePlay/","link":"","permalink":"http://yoursite.com/2019/03/10/AndroidPublishToGooglePlay/","excerpt":"","text":"Android app发布到GooglePlay开头的废话: 最近使用cocoscreator开发的一个游戏的android版本需要发布到google play, 要上传到google play就需要再app中集成google play service, 以前本来接入过,接入过程非常简单,也有发布到google play的应用,结果时间长了居然给忘掉了,google了一下才配置好,所以索性将它记录下来,以免再忘 本文使用的是AndroidStudio的工程进行开发,文章也只是大致讲述在发布到googleplay上,程序配置上需要进行的工作 1. 配置build.gradle在app level下的build.gradle文件中加入google play service的依赖,不配置的话步骤2中的google_play_services_version就找不到定义123dependencies &#123; implementation &apos;com.google.android.gms:play-services:12.0.1&apos;&#125; 2. 配置AndroidManifest.xml12&lt;!-- google play --&gt;&lt;meta-data android:name=&quot;com.google.android.gms.version&quot; android:value=&quot;@integer/google_play_services_version&quot; /&gt; google_play_services_version不需要自己定义,它由google play service定义,它的值也随着google play service的版本变化而变化 上传apk至google play 必须加入这个配置,否则不能成功上传 配置到这里,就已经能够上传到google play了 3.跳转至GooglePlay商店app一般都有个引导评论的功能,android的app一般直接跳转到GooglePlay商店详情页面,用户可以在这里给app打分和评论,附上代码 1234567891011121314151617public static void launchAppDetail() &#123; final String GOOGLE_PLAY = &quot;com.android.vending&quot;;//这里对应的是谷歌商店，跳转别的商店改成对应的即可 try &#123; Uri uri = Uri.parse(&quot;market://details?id=&quot; + mActivity.getPackageName()); Intent intent = new Intent(Intent.ACTION_VIEW, uri); intent.setPackage(GOOGLE_PLAY); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); mActivity.startActivity(intent); &#125; catch (Exception e) &#123; mActivity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; Toast.makeText(mActivity, &quot;GooglePlay Store not exist&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125;&#125;","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"GooglePlay","slug":"GooglePlay","permalink":"http://yoursite.com/tags/GooglePlay/"}]},{"title":"Android工程集成Admob","slug":"AndroidIntegrateAdmob","date":"2019-03-10T06:14:36.000Z","updated":"2019-03-19T14:04:46.809Z","comments":true,"path":"2019/03/10/AndroidIntegrateAdmob/","link":"","permalink":"http://yoursite.com/2019/03/10/AndroidIntegrateAdmob/","excerpt":"","text":"AndroidStudio集成Admob前段时间公司的游戏开发的差不多了，集成了一些SDK，本次要说的就是其中之一的Admob，这个变现sdk就不用介绍了吧，看到这个文章的肯定都知道是什么，实在不清楚就去玩玩度娘。其实Android应用接入Admob没什么复杂的地方，只不过手上这个应用是CocosCreator开发的游戏，就是在一个Activity上面加了个GLView，然后渲染，要接入SDK需要稍微绕一点点弯路，然后国内的网络环境也堪忧，有可能会在测试的时候带来麻烦。 Android GL线程与UI线程通信熟悉Cocos的同学都知道，我们的游戏都是在一个GLview上进行的，游戏开发的语言是js，要想与UI线程通信，就需要引擎提供的api1jsb.reflection.callStaticMethod(&apos;类路径&apos;, &apos;方法名&apos;, &apos;参数签名&apos;, &apos;参数列表&apos;); 只有静态方法可以通过这个方式进行调用，关于这个方法的详细说明就不过多赘述，官方文档有很详细的讲解 [ 传送门 ]。 接入Admob依赖库首先在工程级的build.gradle中添加依赖(最外层的那个build.gralde文件)12345678allprojects &#123; repositories &#123; jcenter() maven &#123; url &quot;https://maven.google.com&quot; &#125; &#125;&#125; 再在app级的build.gradle中添加相关库的依赖(定义了applicationid等应用信息的那个build.gradle)1234dependencies &#123; //new dependence implementation &apos;com.google.android.gms:play-services-ads:15.0.0&apos;&#125; 到这里库的配置就弄完了，可以开始撸代码了 注意，Admob要求的Target Android API level 最低是14，不然编译阶段会提示你修改 接入Banner广告Banner广告就是一个显示在屏幕某个位置的横幅广告，难以避免地会占用游戏节目，是个很不友好的广告，在Android原生应用中，可以直接在要植入广告的界面的xml布局里面直接把banner广告布局填进去，适配也非常的简单，但是我这游戏就不行，cocos的长度单位与Android的不一样，需要经过一些换算才能得到正确的大小，Banner广告展示的大小，SDK有提供了很多尺寸的选择，其中Smart Banner是SDK自己进行适配，如果广告内容把游戏内容遮挡了，这肯定是非常不好的，所以我非常咸鱼的选择了最小的尺寸(快速迭代嘛，以后再优化 &gt;_&lt; )，下面直接贴代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546//首先初始化Admob mActivity就是游戏的主Activity，admob相关的id找让你接sdk的人要，嘻嘻MobileAds.initialize(mActivity,mActivity.getResources().getString(R.string.admob_appid));mActivity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; bannerAd = new AdView(mActivity); bannerAd.setAdUnitId(mActivity.getResources().getString(R.string.admob_banner_id)); bannerAd.setAdSize(AdSize.BANNER); bannerAd.setAdListener(bannerAdListener); AdRequest adRequest = new AdRequest.Builder() .addTestDevice(&quot;test_device_id&quot;) .build(); bannerAd.loadAd(adRequest); &#125; &#125;); public static AdListener bannerAdListener = new AdListener()&#123; @Override public void onAdLoaded() &#123; mActivity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; if(bannerAd.getParent() == null)&#123; FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT); params.gravity = Gravity.BOTTOM; mActivity.addContentView(bannerAd, params); &#125;else&#123; &#125; &#125; &#125;); &#125; @Override public void onAdFailedToLoad(final int errorCode) &#123; &#125; @Override public void onAdOpened() &#123; &#125; @Override public void onAdLeftApplication() &#123; &#125; @Override public void onAdClosed() &#123; &#125;); &#125; &#125;; 由于我们不能直接在GL thread去修改UI thread，所以我们这里用了个runOnUIthread包装了一下，也可以用其他方式去实现bannerAd.setAdListener(bannerAdListener) 是广告的生命周期的监听函数，广告的状态发生变化都会再这里得到通知，我这里在广告Load成功后对banner广告的UI进行了操作，如果Banner没有添加到Activity中就把它添加进去，并且把它放到了屏幕最底部，之所以加判断是因为Banner是会自己进行一定频率的刷新，如果每次Load成功都去添加一个到场景，老板知道了就要开除我了 接入插屏广告插屏广告·是一种完全覆盖游戏的广告，需要用户手动点击关闭按钮才会消失，这个的接入相比Banner就简单点了，由于产品要求要确保广告在某个时间点弹出来，所以插屏这里我预先进行了Load操作，然后在要展示的时候才show它，因为加载插屏是有一定的延迟的，如果广告内容是视频的话，延迟就更明显了，还是贴上代码123456789101112131415161718192021222324252627//加载插屏广告mActivity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; Log.e(DEBUG_TAG,&quot;loadInterstitial&quot;); AdRequest request = new AdRequest.Builder() .addTestDevice(&quot;test_device_id&quot;) .build(); interstitialAd.setAdListener(interstitialAdListener); interstitialAd.loadAd(request); &#125; &#125;);//展示插屏广告 //一定要确保在UI线程操作 mActivity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; if(interstitialAd.isLoaded())&#123; interstitialAd.show(); &#125;else if(interstitialAd.isLoading())&#123; &#125;else&#123; //如果没有loading，或者load失败了就进行load loadInterstitial(curInterstitialAdPos); &#125; &#125; &#125;); public static AdListener interstitialAdListener = new AdListener()&#123;&#125; 接入视频广告视频广告的接入和插屏几乎一样，非常简单，这次需要用到广告的回掉，因为这涉及到观看广告的奖励的发放, talk is cheap, show me the code~ 12345678910111213141516171819202122232425//load mActivity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; AdRequest adRequest = new AdRequest.Builder().build(); rewardedVideoAd.loadAd(mActivity.getResources().getString(R.string.admob_rewardedvideo_id),adRequest); &#125; &#125;);//showmActivity.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; if(rewardedVideoAd.isLoaded())&#123; rewardedVideoAd.show(); &#125;else&#123; loadRewardedVideo(); &#125; &#125; &#125;);//广告回掉 //收到这个回掉表示用户完整观看了视频广告，需要发放奖励 @Override public void onRewarded(RewardItem rewardItem) &#123; Log.e(DEBUG_TAG,&quot;onRewarded&quot;); &#125; Always test with test ads ! 进行测试的时候尽量使用文档提供的测试id，一来可以排除掉市场人员app广告信息配置错误，二来这也是官方要求的(不要刷广告)，其实刷也没用，刷着刷着就不给你展示广告了 我为什么突然没广告看了！ 先别急，这一般不是我们程序员的问题(先甩锅),广告没有按预期播放一般有4个原因：1.INTERNAL_ERROR(内部错误) 2.INVALID_REQUEST(非法请求) 3.NETWORK_ERROR(网络错误) 4.NOT_FILL(未填充)所以测试的时候最好能把这些信息实时的输出出来，以便在没能成功展示广告时看到是什么原因（=_=） 有了AndroidStudio，接入广告真的简单了好多，其实还有原生广告和中介还么有说到，原生广告真的是非常的坑爹，这里简单说下中介，通过中介我们可以去接入一些其他的广告来源，目前文章中就能得到来自Admob的广告，通过一些配置就可以得到来自其他广告联盟的广告了，这两个就下次再写一篇讲讲","categories":[],"tags":[{"name":"CocosCreator","slug":"CocosCreator","permalink":"http://yoursite.com/tags/CocosCreator/"},{"name":"Android","slug":"Android","permalink":"http://yoursite.com/tags/Android/"},{"name":"Admob","slug":"Admob","permalink":"http://yoursite.com/tags/Admob/"}]}]}