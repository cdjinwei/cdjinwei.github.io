<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-06-05T16:12:21.545Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jinwei Lei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CocosCreator资源加载和释放</title>
    <link href="http://yoursite.com/2019/05/29/CocosCreator%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%87%8A%E6%94%BE/"/>
    <id>http://yoursite.com/2019/05/29/CocosCreator资源加载和释放/</id>
    <published>2019-05-29T15:37:06.000Z</published>
    <updated>2019-06-05T16:12:21.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CocosCreator资源加载和释放"><a href="#CocosCreator资源加载和释放" class="headerlink" title="CocosCreator资源加载和释放"></a>CocosCreator资源加载和释放</h2><blockquote><p>CocosCreator的官方文档对资源的加载和释放方面描述的不算清楚, 不少人对游戏内存的把控没有信心,今天我就来捋一捋CocosCreator的资源加载和释放,权当是测试一下各个资源加载和释放的接口</p></blockquote><blockquote><p>本文基于CocosCreator2.1.1</p></blockquote><h3 id="0-CocosCreator的resources目录"><a href="#0-CocosCreator的resources目录" class="headerlink" title="0. CocosCreator的resources目录"></a>0. CocosCreator的resources目录</h3><p>使用过CocosCreator的人应该都知道,resorces目录是用来存放那些需要再游戏中动态加载的资源, 官方稳定建议如果资源不需要动态加载,就不要放在该目录下. 经测试, resources目录下的所有资源在构建工程后生成的setting.js文件中有记录,resources目录下的资源越多也就意味着setting.js越大</p><h3 id="1-CocosCreator的各种类型的资源"><a href="#1-CocosCreator的各种类型的资源" class="headerlink" title="1. CocosCreator的各种类型的资源"></a>1. CocosCreator的各种类型的资源</h3><p>在CocosCreator2.1.1版本中,在空场景的情况下cc.loader._cache中一共有20个对象,下文的资源加载和释放的对比将会刨除这20个对象</p><h5 id="1-cc-Texture2D"><a href="#1-cc-Texture2D" class="headerlink" title="(1) cc.Texture2D"></a>(1) cc.Texture2D</h5><p>这是一个基本的图片资源类型,很多游戏都有这个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//加载一个cc.Texture2D类型的资源</span><br><span class="line">cc.loader.loadRes(&apos;pic&apos;, cc.Texture2D, (err, data) =&gt; &#123;</span><br><span class="line">    if(err) return console.log(err);</span><br><span class="line">    console.log(cc.loader._cache);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>以上代码加载完成之后,_cache中多了一个png资源和一个json资源,其中png资源是图片资源是占用内存的大头, 而json资源则代表着一个cc.Texture2D资源对象.<br>在cache中,cc.Texture2D对象是以json文件的名字作为key保存的,单独释放_cache中的png对象,内存并没有明显下降,图片占用的内存明显没有被释放掉,而单独释放json的结果是png和json都被释放掉了,内存也有明显的下降,所以<strong>加载了那些资源就来,释放时就要完完全全把那些资源释放掉</strong></p><ul><li><p>单独释放png, json文件没有被一起释放,内存也没有明显降低</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc.loader.release(&apos;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.png&apos;);</span><br></pre></td></tr></table></figure></li><li><p>单独释放json, png和json都被释放了,内存有明显下降</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc.loader.release(&apos;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.json&apos;);</span><br></pre></td></tr></table></figure></li></ul><p>那么问题来了,怎样知道加载一个cc.Texture2D时还加载了写什么进来呢?<br>cc.loader.getDependsRecursively()可以获取传入对象的所有依赖资源,参数类型为cc.Asset,cc.RawAsset,或者string</p><blockquote><p><strong>cc.Asset</strong>: 在 Creator 中，所有继承自 cc.Asset 的类型都统称资源，如 cc.Texture2D, cc.SpriteFrame, cc.AnimationClip, cc.Prefab 等。它们的加载是统一并且自动化的，相互依赖的资源能够被自动预加载(2.0版本文档原文)<br><strong>cc.RawAsset</strong>: Creator似乎准备把cc.Asset和cc.RawAsset的标准统一起来,在2.0的文档中没有找到cc.RawAsset的说明,应该已经统一了<br><strong>string</strong>: 这里就是资源的路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cc.loader.loadRes(&apos;image&apos;, cc.Texture2D, (err, data) =&gt; &#123;</span><br><span class="line">    //data 就是一个Texture2D对象</span><br><span class="line">    let deps = cc.loader.getDependsRecursively(data);</span><br><span class="line">    console.log(deps);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//deps的输出, 就是加载image时,所加载的所有资源</span><br><span class="line">[&quot;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.png&quot;,</span><br><span class="line">&quot;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.json&quot;]</span><br><span class="line"></span><br><span class="line">//通过资源的路径也能获取到资源的依赖</span><br><span class="line">//获取到的是</span><br><span class="line">//[&apos;8fdd1c3c-1ec9-4018-b57b-551c9b37eba4&apos;]</span><br><span class="line">let deps = cc.loader.getDependsRecursively(&apos;image&apos;);</span><br><span class="line">//这样也能将加载image时所加载的资源全部释放掉</span><br><span class="line">cc.loader.release(deps);</span><br></pre></td></tr></table></figure></p></blockquote><h5 id="1-cc-SpriteFrame"><a href="#1-cc-SpriteFrame" class="headerlink" title="(1) cc.SpriteFrame"></a>(1) cc.SpriteFrame</h5><p>SpriteFrame类似于一个中间件,夹在Texture2D和Sprite之间,当我们以cc.SpriteFrame类型进行资源加载时,我们会得到一个SpriteFrame对象,而通过SpriteFrame对象,我们能够获取到3个依赖资源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cc.loader.loadRes(&apos;image&apos;, cc.SpriteFrame, (err, data) =&gt; &#123;</span><br><span class="line">    //data 就是一个SpriteFrame对象</span><br><span class="line">    let desp = cc.loader.getDependsRecursively(data);</span><br><span class="line">    console.log(desp);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//desp的输出, 就是加载image时,所加载的所有资源</span><br><span class="line">[&quot;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.png&quot;,</span><br><span class="line">&quot;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.json&quot;,</span><br><span class="line">res/import/3e/3e24d7c4-3041-4acd-bc91-378df4a24e5f.json]</span><br></pre></td></tr></table></figure></p><p>前两个资源是我们以cc.Texture2D类型进行加载得到的,第三个资源就代表着我们的SpriteFrame对象,这个SpriteFrame对象在_cache中,就是以这个json文件的名字作为key进行保存的</p><p>在释放以Texture2D类型加载进来的资源时, cc.loader.release(‘image’)能够轻松将加载进来的资源释放掉,而想要释放以SpriteFrame类型加载进来的资源,这么简单的处理将会坑到自己<br>那是因为<strong>从资源路径获取到的依赖资源不包含SpriteFrame</strong>, 如果这样鲁莽释放,加载进来的SpriteFrame就残留在了cache中,当我们再次以SpriteFrame类型加载这个资源时,<strong>由于cache中残留的SpriteFrame对象,loader将不会加载资源,而是直接返回了cache中这个已经丢失了Texture2D的SpriteFrame</strong>,我们此时可以在控制台中看到一大片的webgl的警告</p><h3 id="2-如何优雅地释放资源"><a href="#2-如何优雅地释放资源" class="headerlink" title="2. 如何优雅地释放资源"></a>2. 如何优雅地释放资源</h3><h5 id="资源引用计数"><a href="#资源引用计数" class="headerlink" title="资源引用计数"></a>资源引用计数</h5><p>对于释放动态加载的资源,有些人的做法是在加载时获取到加载资源的完整依赖进行累加计数,在释放时对对应资源减一,引用为0时进行真正的释放</p><h5 id="资源份文件夹管理"><a href="#资源份文件夹管理" class="headerlink" title="资源份文件夹管理"></a>资源份文件夹管理</h5><p>另一种做法是把各个界面和场景自己才会用到的资源分文件夹管理,然后通用资源用另一个文件夹管理,在游戏离开某个界面进入另一个界面时,将除通用资源以外的资源统统释放掉</p><blockquote><p>我个人目前还是跟喜欢后一种做法,一个原因是自己没有一个好的引用计数的实现,另一个原因是经常用到的资源可能会时不时被释放掉,而再次加载有需要一定的时间,会造成不好的体验,就使用了后一种做法</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CocosCreator资源加载和释放&quot;&gt;&lt;a href=&quot;#CocosCreator资源加载和释放&quot; class=&quot;headerlink&quot; title=&quot;CocosCreator资源加载和释放&quot;&gt;&lt;/a&gt;CocosCreator资源加载和释放&lt;/h2&gt;&lt;bloc
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CocosCreatorWeb调试模拟IphoneX</title>
    <link href="http://yoursite.com/2019/03/19/CocosCreatorWeb%E8%B0%83%E8%AF%95%E6%A8%A1%E6%8B%9FIphoneX/"/>
    <id>http://yoursite.com/2019/03/19/CocosCreatorWeb调试模拟IphoneX/</id>
    <published>2019-03-19T14:09:11.000Z</published>
    <updated>2019-03-19T14:50:43.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CocosCreatorWeb调试模拟IphoneX"><a href="#CocosCreatorWeb调试模拟IphoneX" class="headerlink" title="CocosCreatorWeb调试模拟IphoneX"></a>CocosCreatorWeb调试模拟IphoneX</h1><p>CocosCreator的web调试工具，默认提供了模拟多种设备分辨率的选项，但通常开发者都会有特殊的适配需求(适配iphonex等刘海屏)，CocosCreator并没有涵盖到也很难涵盖到各种分辨率，不过开发者可以自行添加<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/19/CocosCreatorWeb调试模拟IphoneX/cocos_web_simulator_2019-03-19_22-01-38.png" alt="CocosCreator默认提供的选项" title>                </div>                <div class="image-caption">CocosCreator默认提供的选项</div>            </figure></p><h2 id="设置自定义分辨率"><a href="#设置自定义分辨率" class="headerlink" title="设置自定义分辨率"></a>设置自定义分辨率</h2><p>在CocosCreator\resources\static\preview-templates下的boot.js中有分辨率模拟选项的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// init device resolutions</span><br><span class="line">    var devices = [</span><br><span class="line">        &#123; name: &apos;Apple iPad&apos;, width: 1024, height: 768, ratio: 2 &#125;,</span><br><span class="line">        &#123; name: &apos;Apple iPad Mini&apos;, width: 1024, height: 768, ratio: 1 &#125;,</span><br><span class="line">        &#123; name: &apos;Apple iPhone 4&apos;, width: 320, height: 480, ratio: 2 &#125;,</span><br><span class="line">        &#123; name: &apos;Apple iPhone 5&apos;, width: 320, height: 568, ratio: 2 &#125;,</span><br><span class="line">        &#123; name: &apos;Apple iPhone 6&apos;, width: 375, height: 667, ratio: 2 &#125;,</span><br><span class="line">        &#123; name: &apos;Apple iPhone 6 Plus&apos;, width: 414, height: 736, ratio: 3 &#125;,</span><br><span class="line">        &#123; name: &apos;Huawei P9&apos;, width: 540, height: 960, ratio: 2&#125;,</span><br><span class="line">        &#123; name: &apos;Huawei Mate9 Pro&apos;, width: 720, height: 1280, ratio: 2&#125;,</span><br><span class="line">        &#123; name: &apos;Goolge Nexus 4&apos;, width: 384, height: 640, ratio: 2 &#125;,</span><br><span class="line">        &#123; name: &apos;Goolge Nexus 5&apos;, width: 360, height: 640, ratio: 3 &#125;,</span><br><span class="line">        &#123; name: &apos;Goolge Nexus 6&apos;, width: 412, height: 732, ratio: 3.5 &#125;,</span><br><span class="line">        &#123; name: &apos;Goolge Nexus 7&apos;, width: 960, height: 600, ratio: 2 &#125;,</span><br><span class="line">        &#123; name: &apos;Iphone X&apos;, width: 375, height: 812, ratio: 3 &#125;,</span><br><span class="line">    ];</span><br></pre></td></tr></table></figure></p><p>只需要按照已有的格式添加就可以了</p><ul><li>name：模拟器选项中展示的名字</li><li>width：模拟器在网页上实际的宽度</li><li>height：模拟器在网页上实际的高度</li><li>ratio：字面意思是缩放比例，但是修改过后没有产生效果？<br>我在devices中加入了iphonex的分辨率信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; name: &apos;Iphone X&apos;, width: 1125, height: 2436, ratio: 1 &#125;</span><br></pre></td></tr></table></figure></li></ul><p>预览后发现游戏画面已经超过了浏览器窗口的大小，出现了滑动条，所以将宽高缩小3倍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; name: &apos;Iphone X&apos;, width: 375, height: 812, ratio: 3 &#125;,</span><br></pre></td></tr></table></figure></p><p>刷新页面得到了能够正常预览的大小<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/19/CocosCreatorWeb调试模拟IphoneX/iphonex_2019-03-19_22-45-44.png" alt="IphoneXWeb模拟器" title>                </div>                <div class="image-caption">IphoneXWeb模拟器</div>            </figure></p><blockquote><p>虽然web模拟器调试非常便利，但是适配IphoneX还是要以实机效果为准</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CocosCreatorWeb调试模拟IphoneX&quot;&gt;&lt;a href=&quot;#CocosCreatorWeb调试模拟IphoneX&quot; class=&quot;headerlink&quot; title=&quot;CocosCreatorWeb调试模拟IphoneX&quot;&gt;&lt;/a&gt;CocosCre
      
    
    </summary>
    
    
      <category term="CocosCreator" scheme="http://yoursite.com/tags/CocosCreator/"/>
    
  </entry>
  
  <entry>
    <title>GooglePlay会对apk重新签名</title>
    <link href="http://yoursite.com/2019/03/10/GooglePlay%E4%BC%9A%E5%AF%B9apk%E9%87%8D%E6%96%B0%E7%AD%BE%E5%90%8D/"/>
    <id>http://yoursite.com/2019/03/10/GooglePlay会对apk重新签名/</id>
    <published>2019-03-10T08:17:24.000Z</published>
    <updated>2019-03-10T08:18:09.834Z</updated>
    
    <content type="html"><![CDATA[<h2 id="上传到GooglePlay的Apk会被重新签名"><a href="#上传到GooglePlay的Apk会被重新签名" class="headerlink" title="上传到GooglePlay的Apk会被重新签名"></a>上传到GooglePlay的Apk会被重新签名</h2><p>最近在准备发布新版本的时候,测试同学发现新版本的apk覆盖老版本的时候安装失败了,通过命令行安装发现问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failure [INSTALL_FAILED_UPDATE_INCOMPATIBLE: Package your.package.name signatures do not match the previously installed version; ignoring!]</span><br></pre></td></tr></table></figure><p>意思是两个版本的Apk签名不同,新版本的Apk能够确定是用release签名打包的,难道老版本的包是用了debug的签名吗?,经过排查老版本的包也是用的release签名,打包配置也都是同一套配置.</p><p>最后问题指向GooglePlay,应该是上传到GooglePlay后,被重新签名了,我将从googleplay下载的包卸载掉,安装本地的低版本,然后用高版本覆盖安装,果然没有问题,应该就是googleplay重新签名了,最后上传新包到googleplay成功上传,验证了猜想(因为签名如果不一致是不能上传成功的),最后发布更新可以正常更新</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;上传到GooglePlay的Apk会被重新签名&quot;&gt;&lt;a href=&quot;#上传到GooglePlay的Apk会被重新签名&quot; class=&quot;headerlink&quot; title=&quot;上传到GooglePlay的Apk会被重新签名&quot;&gt;&lt;/a&gt;上传到GooglePlay的Apk
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="GooglePlay" scheme="http://yoursite.com/tags/GooglePlay/"/>
    
      <category term="apk签名" scheme="http://yoursite.com/tags/apk%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android应用发布到GooglePlay</title>
    <link href="http://yoursite.com/2019/03/10/AndroidPublishToGooglePlay/"/>
    <id>http://yoursite.com/2019/03/10/AndroidPublishToGooglePlay/</id>
    <published>2019-03-10T07:42:37.000Z</published>
    <updated>2019-03-19T14:05:02.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-app发布到GooglePlay"><a href="#Android-app发布到GooglePlay" class="headerlink" title="Android app发布到GooglePlay"></a>Android app发布到GooglePlay</h1><p>开头的废话: 最近使用cocoscreator开发的一个游戏的android版本需要发布到google play, 要上传到google play就需要再app中集成google play service, 以前本来接入过,接入过程非常简单,也有发布到google play的应用,结果时间长了居然给忘掉了,google了一下才配置好,所以索性将它记录下来,以免再忘</p><blockquote><p>本文使用的是AndroidStudio的工程进行开发,文章也只是大致讲述在发布到googleplay上,程序配置上需要进行的工作</p></blockquote><hr><h3 id="1-配置build-gradle"><a href="#1-配置build-gradle" class="headerlink" title="1. 配置build.gradle"></a>1. 配置build.gradle</h3><p>在app level下的build.gradle文件中加入google play service的依赖,不配置的话步骤2中的google_play_services_version就找不到定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &apos;com.google.android.gms:play-services:12.0.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-配置AndroidManifest-xml"><a href="#2-配置AndroidManifest-xml" class="headerlink" title="2. 配置AndroidManifest.xml"></a>2. 配置AndroidManifest.xml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- google play --&gt;</span><br><span class="line">&lt;meta-data android:name=&quot;com.google.android.gms.version&quot; android:value=&quot;@integer/google_play_services_version&quot; /&gt;</span><br></pre></td></tr></table></figure><p>google_play_services_version不需要自己定义,它由google play service定义,它的值也随着google play service的版本变化而变化</p><blockquote><p>上传apk至google play 必须加入这个配置,否则不能成功上传</p></blockquote><p>配置到这里,就已经能够上传到google play了</p><h3 id="3-跳转至GooglePlay商店"><a href="#3-跳转至GooglePlay商店" class="headerlink" title="3.跳转至GooglePlay商店"></a>3.跳转至GooglePlay商店</h3><p>app一般都有个引导评论的功能,android的app一般直接跳转到GooglePlay商店详情页面,用户可以在这里给app打分和评论,附上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void launchAppDetail() &#123;</span><br><span class="line">    final String GOOGLE_PLAY = &quot;com.android.vending&quot;;//这里对应的是谷歌商店，跳转别的商店改成对应的即可</span><br><span class="line">    try &#123;</span><br><span class="line">        Uri uri = Uri.parse(&quot;market://details?id=&quot; + mActivity.getPackageName());</span><br><span class="line">        Intent intent = new Intent(Intent.ACTION_VIEW, uri);</span><br><span class="line">        intent.setPackage(GOOGLE_PLAY);</span><br><span class="line">        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">        mActivity.startActivity(intent);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        mActivity.runOnUiThread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Toast.makeText(mActivity, &quot;GooglePlay Store not exist&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android-app发布到GooglePlay&quot;&gt;&lt;a href=&quot;#Android-app发布到GooglePlay&quot; class=&quot;headerlink&quot; title=&quot;Android app发布到GooglePlay&quot;&gt;&lt;/a&gt;Android app发布到
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="GooglePlay" scheme="http://yoursite.com/tags/GooglePlay/"/>
    
  </entry>
  
  <entry>
    <title>Android工程集成Admob</title>
    <link href="http://yoursite.com/2019/03/10/AndroidIntegrateAdmob/"/>
    <id>http://yoursite.com/2019/03/10/AndroidIntegrateAdmob/</id>
    <published>2019-03-10T06:14:36.000Z</published>
    <updated>2019-03-19T14:04:46.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AndroidStudio集成Admob"><a href="#AndroidStudio集成Admob" class="headerlink" title="AndroidStudio集成Admob"></a>AndroidStudio集成Admob</h1><p>前段时间公司的游戏开发的差不多了，集成了一些SDK，本次要说的就是其中之一的Admob，这个变现sdk就不用介绍了吧，看到这个文章的肯定都知道是什么，实在不清楚就去玩玩度娘。其实Android应用接入Admob没什么复杂的地方，只不过手上这个应用是CocosCreator开发的游戏，就是在一个Activity上面加了个GLView，然后渲染，要接入SDK需要稍微绕一点点弯路，然后国内的网络环境也堪忧，有可能会在测试的时候带来麻烦。</p><h3 id="Android-GL线程与UI线程通信"><a href="#Android-GL线程与UI线程通信" class="headerlink" title="Android GL线程与UI线程通信"></a>Android GL线程与UI线程通信</h3><p>熟悉Cocos的同学都知道，我们的游戏都是在一个GLview上进行的，游戏开发的语言是js，要想与UI线程通信，就需要引擎提供的api<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsb.reflection.callStaticMethod(&apos;类路径&apos;, &apos;方法名&apos;, &apos;参数签名&apos;, &apos;参数列表&apos;);</span><br></pre></td></tr></table></figure></p><p>只有静态方法可以通过这个方式进行调用，关于这个方法的详细说明就不过多赘述，官方文档有很详细的讲解<a href="http://docs.cocos.com/creator/manual/zh/advanced-topics/java-reflection.html" target="_blank" rel="noopener"> [ 传送门 ]</a>。</p><h3 id="接入Admob依赖库"><a href="#接入Admob依赖库" class="headerlink" title="接入Admob依赖库"></a>接入Admob依赖库</h3><p>首先在工程级的build.gradle中添加依赖(最外层的那个build.gralde文件)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &quot;https://maven.google.com&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再在app级的build.gradle中添加相关库的依赖(定义了applicationid等应用信息的那个build.gradle)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">//new dependence</span><br><span class="line">    implementation &apos;com.google.android.gms:play-services-ads:15.0.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里库的配置就弄完了，可以开始撸代码了</p><blockquote><p>注意，Admob要求的Target Android API level 最低是14，不然编译阶段会提示你修改</p></blockquote><h3 id="接入Banner广告"><a href="#接入Banner广告" class="headerlink" title="接入Banner广告"></a>接入Banner广告</h3><p>Banner广告就是一个显示在屏幕某个位置的横幅广告，难以避免地会占用游戏节目，是个很不友好的广告，在Android原生应用中，可以直接在要植入广告的界面的xml布局里面直接把banner广告布局填进去，适配也非常的简单，但是我这游戏就不行，cocos的长度单位与Android的不一样，需要经过一些换算才能得到正确的大小，Banner广告展示的大小，SDK有提供了很多尺寸的选择，其中Smart Banner是SDK自己进行适配，如果广告内容把游戏内容遮挡了，这肯定是非常不好的，所以我非常咸鱼的选择了最小的尺寸(快速迭代嘛，以后再优化 &gt;_&lt; )，下面直接贴代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//首先初始化Admob mActivity就是游戏的主Activity，admob相关的id找让你接sdk的人要，嘻嘻</span><br><span class="line">MobileAds.initialize(mActivity,mActivity.getResources().getString(R.string.admob_appid));</span><br><span class="line"></span><br><span class="line">mActivity.runOnUiThread(new Runnable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               bannerAd = new AdView(mActivity);</span><br><span class="line">               bannerAd.setAdUnitId(mActivity.getResources().getString(R.string.admob_banner_id));</span><br><span class="line">               bannerAd.setAdSize(AdSize.BANNER);</span><br><span class="line">               bannerAd.setAdListener(bannerAdListener);</span><br><span class="line">               </span><br><span class="line">               AdRequest adRequest = new AdRequest.Builder()</span><br><span class="line">                       .addTestDevice(&quot;test_device_id&quot;)</span><br><span class="line">                       .build();</span><br><span class="line">               bannerAd.loadAd(adRequest);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">    public static AdListener bannerAdListener = new AdListener()&#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void onAdLoaded() &#123;</span><br><span class="line">           mActivity.runOnUiThread(new Runnable() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void run() &#123;</span><br><span class="line">                   if(bannerAd.getParent() == null)&#123;</span><br><span class="line">                       FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT);</span><br><span class="line">                       params.gravity = Gravity.BOTTOM;</span><br><span class="line">                       mActivity.addContentView(bannerAd, params);</span><br><span class="line">                   &#125;else&#123;  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void onAdFailedToLoad(final int errorCode) &#123; &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void onAdOpened() &#123; &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void onAdLeftApplication() &#123;  &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void onAdClosed() &#123; &#125;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure></p><p>由于我们不能直接在GL thread去修改UI thread，所以我们这里用了个runOnUIthread包装了一下，也可以用其他方式去实现<br>bannerAd.setAdListener(bannerAdListener) 是广告的生命周期的监听函数，广告的状态发生变化都会再这里得到通知，我这里在广告Load成功后对banner广告的UI进行了操作，如果Banner没有添加到Activity中就把它添加进去，并且把它放到了屏幕最底部，之所以加判断是因为Banner是会自己进行一定频率的刷新，如果每次Load成功都去添加一个到场景，老板知道了就要开除我了</p><h3 id="接入插屏广告"><a href="#接入插屏广告" class="headerlink" title="接入插屏广告"></a>接入插屏广告</h3><p>插屏广告·是一种完全覆盖游戏的广告，需要用户手动点击关闭按钮才会消失，这个的接入相比Banner就简单点了，由于产品要求要确保广告在某个时间点弹出来，所以插屏这里我预先进行了Load操作，然后在要展示的时候才show它，因为加载插屏是有一定的延迟的，如果广告内容是视频的话，延迟就更明显了，还是贴上代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//加载插屏广告</span><br><span class="line">mActivity.runOnUiThread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Log.e(DEBUG_TAG,&quot;loadInterstitial&quot;);</span><br><span class="line">                AdRequest request = new AdRequest.Builder()</span><br><span class="line">                        .addTestDevice(&quot;test_device_id&quot;)</span><br><span class="line">                        .build();</span><br><span class="line">                interstitialAd.setAdListener(interstitialAdListener);</span><br><span class="line">                interstitialAd.loadAd(request);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">//展示插屏广告</span><br><span class="line">//一定要确保在UI线程操作</span><br><span class="line">        mActivity.runOnUiThread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                if(interstitialAd.isLoaded())&#123;</span><br><span class="line">                    interstitialAd.show();</span><br><span class="line">                &#125;else if(interstitialAd.isLoading())&#123;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                //如果没有loading，或者load失败了就进行load</span><br><span class="line">                    loadInterstitial(curInterstitialAdPos);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        public static AdListener interstitialAdListener = new AdListener()&#123;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="接入视频广告"><a href="#接入视频广告" class="headerlink" title="接入视频广告"></a>接入视频广告</h3><p>视频广告的接入和插屏几乎一样，非常简单，这次需要用到广告的回掉，因为这涉及到观看广告的奖励的发放,<br> talk is cheap, show me the code~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//load</span><br><span class="line">        mActivity.runOnUiThread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                AdRequest adRequest = new AdRequest.Builder().build();</span><br><span class="line">                rewardedVideoAd.loadAd(mActivity.getResources().getString(R.string.admob_rewardedvideo_id),adRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">//show</span><br><span class="line">mActivity.runOnUiThread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                if(rewardedVideoAd.isLoaded())&#123;</span><br><span class="line">                    rewardedVideoAd.show();</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    loadRewardedVideo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">//广告回掉</span><br><span class="line">//收到这个回掉表示用户完整观看了视频广告，需要发放奖励</span><br><span class="line">    @Override</span><br><span class="line">    public void onRewarded(RewardItem rewardItem) &#123;</span><br><span class="line">        Log.e(DEBUG_TAG,&quot;onRewarded&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Always test with test ads !</p><blockquote><p>进行测试的时候尽量使用文档提供的测试id，一来可以排除掉市场人员app广告信息配置错误，二来这也是官方要求的(不要刷广告)，其实刷也没用，刷着刷着就不给你展示广告了</p></blockquote><hr><p>我为什么突然没广告看了！</p><blockquote><p>先别急，这一般不是我们程序员的问题(先甩锅),广告没有按预期播放一般有4个原因：<br>1.INTERNAL_ERROR(内部错误) 2.INVALID_REQUEST(非法请求) 3.NETWORK_ERROR(网络错误) 4.NOT_FILL(未填充)<br>所以测试的时候最好能把这些信息实时的输出出来，以便在没能成功展示广告时看到是什么原因（=_=）</p></blockquote><p>有了AndroidStudio，接入广告真的简单了好多，其实还有原生广告和中介还么有说到，原生广告真的是非常的坑爹，这里简单说下中介，通过中介我们可以去接入一些其他的广告来源，目前文章中就能得到来自Admob的广告，通过一些配置就可以得到来自其他广告联盟的广告了，这两个就下次再写一篇讲讲</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AndroidStudio集成Admob&quot;&gt;&lt;a href=&quot;#AndroidStudio集成Admob&quot; class=&quot;headerlink&quot; title=&quot;AndroidStudio集成Admob&quot;&gt;&lt;/a&gt;AndroidStudio集成Admob&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="CocosCreator" scheme="http://yoursite.com/tags/CocosCreator/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Admob" scheme="http://yoursite.com/tags/Admob/"/>
    
  </entry>
  
</feed>
