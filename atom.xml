<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-07T14:09:28.875Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Jinwei Lei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>寻路算法</title>
    <link href="http://yoursite.com/2019/07/07/SearchPath/"/>
    <id>http://yoursite.com/2019/07/07/SearchPath/</id>
    <published>2019-07-07T14:09:52.000Z</published>
    <updated>2019-07-07T14:09:28.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-寻路算法"><a href="#A-寻路算法" class="headerlink" title="A*寻路算法"></a>A*寻路算法</h1><blockquote><p>A*寻路算是游戏开发中很常见的一种寻路算法，网络上相关的介绍也非常多，这次从其他寻路算法谈起，来看一看A星算法是如何诞生的，本文所有寻路算法使用TypeScript实现</p><p><strong>算法默认权重不为负数</strong></p></blockquote><h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><p>广度优先搜索，就如同洪水一样，从搜索起点不断往外扩张</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/07/07/SearchPath/breadthfirst.gif" alt="BreadthFirst" title>                </div>                <div class="image-caption">BreadthFirst</div>            </figure><h3 id="搜索实现"><a href="#搜索实现" class="headerlink" title="搜索实现"></a>搜索实现</h3><ol><li>构建一个搜索队列searchList，列表中的节点就是等待搜索的节点，初始化时将起点加入到列表中; 构建一个searchRecord记录被搜索过的节点</li><li>从searchList搜索队列中取出一个节点，获取到该节点的临近节点(这里取上下左右4个节点)，若临近节点没有被搜索过，将临近节点加入到searchList中</li><li>重复步骤2，直到搜索完所有节点</li></ol><h3 id="提前结束"><a href="#提前结束" class="headerlink" title="提前结束"></a>提前结束</h3><p>上面的搜索步骤是地图中所有节点进行遍历，实际上寻路都存在一个或多个目标，当搜索到目标就可以停止算法，避免不必要的查询</p><h3 id="关于searchRecord"><a href="#关于searchRecord" class="headerlink" title="关于searchRecord"></a>关于searchRecord</h3><p>serachRecord用来记录搜索过的节点，当寻找到最终目标，最终的搜索路径就通过serachRecord构建出来, 我这里使用的是一个Dictionay来实现的，key是由节点的xy值构成的一个字符串，以表示一个唯一的节点，<br>比如，当我们以(5,5)为起点，[(4, 5), (5, 4), (5, 6), (6, 5)]这四个点将会被搜索，那么searchReocrd的结构就是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">searchRecord = &#123;</span><br><span class="line">    &apos;4_5&apos;: Node(5, 5),</span><br><span class="line">    &apos;5_4&apos;: Node(5, 5),</span><br><span class="line">    &apos;5_6&apos;: Node(5, 5),</span><br><span class="line">    &apos;6_5&apos;: Node(5, 5)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的结构表明了key与value的父子关系: (5, 5) -&gt; (4, 5), 当搜索继续下去，可能会出现下面的结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">searchRecord = &#123;</span><br><span class="line">    &apos;4_5&apos;: Node(5, 5),</span><br><span class="line">    &apos;3_5&apos;: Node(4, 5),</span><br><span class="line">    &apos;2_5&apos;: Node(3, 5),</span><br><span class="line">    &apos;1_5&apos;: Node(2, 5),</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假如(1, 5)是我们的终点，那么根据searchRecord我们可以轻松构建出最终的搜索路径: (5, 5) -&gt; (4, 5) -&gt; (3, 5) -&gt; (2, 5) -&gt; (1, 5) </p><p><img src="/2019/07/07/SearchPath/breadthfirst2.gif" alt="&#39;BreadthFirst 2&#39;"></p><h3 id="核心代码实现"><a href="#核心代码实现" class="headerlink" title="核心代码实现"></a>核心代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let searchQueue: Array&lt;Node&gt; = [start];</span><br><span class="line">let searchRecord = &#123;&#125;</span><br><span class="line"></span><br><span class="line">searchRecord[start.toString()] = true;</span><br><span class="line">while(searchQueue.length)&#123;</span><br><span class="line">    let current = searchQueue.shift();</span><br><span class="line">    //找到目标，终止搜索</span><br><span class="line">    if(current.toString() == end.toString())&#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    //获取搜索节点的所有邻居节点</span><br><span class="line">    let neighbors = this.getNeighbors(current);</span><br><span class="line">    for(let node of neighbors)&#123;</span><br><span class="line">        if(!searchRecord[node.toString()])&#123;</span><br><span class="line">            searchQueue.push(node);</span><br><span class="line">            //确定父子关系</span><br><span class="line">            searchRecord[node.toString()] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dijkstra搜索"><a href="#Dijkstra搜索" class="headerlink" title="Dijkstra搜索"></a>Dijkstra搜索</h2><p>通常在游戏中，角色在不同的环境，机动能力是不同的，角色通过一格平原可能花费1点行动力，通过山地就要花费3点，还有河流，冰川….. 在广度优先搜索中，searchList中的节点没有权重的概念，而Dijkstra算法在广度优先搜索的基础上加入了权重，权重高(游戏中可能表现为移动损耗低)的节点会优先进行搜索， 以寻找移动损耗更低的路径</p><h3 id="搜索节点加权"><a href="#搜索节点加权" class="headerlink" title="搜索节点加权"></a>搜索节点加权</h3><p>Dijkstra搜索中，每个节点都有一个权重值，代表着移动所需要的消耗，广度优先搜索其实也是特殊的Dijkstra搜索，所有的节点权重都是1</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/07/07/SearchPath/dijkstra1.png" alt="Dijkstra搜索" title>                </div>                <div class="image-caption">Dijkstra搜索</div>            </figure><p>在上图中，以绿色点为起点进行搜索，首先将4个黄色的邻居节点加入到搜索列表中，他们以降序权重(值越小权重越高)在列表中排列：[1, 3, 4, 5]，下一轮搜索将取“1”节点进行搜索，重复上述的步骤，直到搜索结束</p><p>在算法中，新加入了一个Dictionary costRecord用来记录从起点到每一个节点的消耗，每个节点的消耗=父节点的消耗+节点的权重值; 如果节点已经搜索过，就不再搜索</p><h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p>这里不能简单的使用广度优先搜索的list，在加入新的节点到searchList中时，我们需要对节点进行排序，搜索的时候直接从队头或队尾(取决于排序的升降序)取出节点进行搜索</p><h3 id="如何保证最后的路径就是cost最低的路径？"><a href="#如何保证最后的路径就是cost最低的路径？" class="headerlink" title="如何保证最后的路径就是cost最低的路径？"></a>如何保证最后的路径就是cost最低的路径？</h3><p>因为在搜索循环中，始终是先搜索cost最低的节点，最先抵达终点的路径必定是cost最低的路径</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/07/07/SearchPath/dijkstra.gif" alt="Dijkstra搜索示意图" title>                </div>                <div class="image-caption">Dijkstra搜索示意图</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/07/07/SearchPath/dijkstra_arrow.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>上图中，箭头指向的节点表示是箭头所在的节点是被箭头指向的节点搜索到的，搜索的范围像洪水一样往外扩展，左上角由于被过高cost的节点阻挡，终止了搜索，searchRecord记录了所有搜索路径，因为是先搜索最低cost的节点，所以最先抵达终点的路径就是最低cost路径(<em>试想一下，算法以最低代价进行搜索找到的节点，还会有另一条代价更低的路径到这个节点吗</em>)</p><h3 id="核心代码实现-1"><a href="#核心代码实现-1" class="headerlink" title="核心代码实现"></a>核心代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let searchQueue: PriorityQueue = new PriorityQueue();</span><br><span class="line">let searchRecord = &#123;&#125;;</span><br><span class="line">let costRecord = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">searchQueue.put(start, 0);</span><br><span class="line">searchRecord[start.toString()] = true;</span><br><span class="line">costRecord[start.toString()] = 0;</span><br><span class="line"></span><br><span class="line">while(searchQueue.length)&#123;</span><br><span class="line">    let current = searchQueue.get();</span><br><span class="line">    if(current.getNode().toString() == end.toString())&#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    let neighbors = this.getNeighbors(current.node);</span><br><span class="line">    for(let node of neighbors)&#123;</span><br><span class="line">        let newCost = costRecord[current.node.toString()] + node.cost;</span><br><span class="line">        if(costRecord[node.toString()] === undefined)&#123;</span><br><span class="line">            searchRecord[node.toString()] = current.getNode();</span><br><span class="line">            costRecord[node.toString()] = newCost;</span><br><span class="line">            searchQueue.put(node, newCost);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最佳优先搜索"><a href="#最佳优先搜索" class="headerlink" title="最佳优先搜索"></a>最佳优先搜索</h2><p>上面提到的两种算法，都是在不断的搜索地图里面的节点，当“碰巧”遇到了目标节点，才结束查询，期间有太多无意义的搜索; 而我们寻路是知道目标的方位的，查找的时候直接朝这个放下搜索不久可以省去多余的搜索了么，最佳优先搜索就是这么干的</p><h3 id="以离目标的距离为优先级"><a href="#以离目标的距离为优先级" class="headerlink" title="以离目标的距离为优先级"></a>以离目标的距离为优先级</h3><p>该算法计算每一个节点到终点的距离，优先搜索距离目标最近的节点，这样搜索就是朝着目标不断前进的</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/07/07/SearchPath/bestfirst.gif" alt="相比广度优先搜索算法，省去了大量的搜索" title>                </div>                <div class="image-caption">相比广度优先搜索算法，省去了大量的搜索</div>            </figure><h3 id="何如结算节点与目标的距离"><a href="#何如结算节点与目标的距离" class="headerlink" title="何如结算节点与目标的距离"></a>何如结算节点与目标的距离</h3><p>在我们的例子中，只有上下左右四个移动方向，使用<em>曼哈顿距离</em>最为合适，所谓曼哈顿距离，就是两个节点的x轴与y轴的距离之和<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">heuristics(start: Node, end: Node)&#123;</span><br><span class="line">    return Math.abs(start.x - end.x) + Math.abs(start.y - end.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="核心代码实现-2"><a href="#核心代码实现-2" class="headerlink" title="核心代码实现"></a>核心代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let searchQueue: PriorityQueue = new PriorityQueue();</span><br><span class="line">let searchRecord = &#123;&#125;;</span><br><span class="line">searchQueue.put(start, this.heuristics(start, end));</span><br><span class="line">searchRecord[start.toString()] = true;</span><br><span class="line"></span><br><span class="line">while(searchQueue.length)&#123;</span><br><span class="line">    let current = searchQueue.get();</span><br><span class="line">    if(current.getNode().toString() == end.toString())&#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    let neighbors = this.getNeighbors(current.node);</span><br><span class="line">    for(let node of neighbors)&#123;</span><br><span class="line">        if(!searchRecord[node.toString()])&#123;</span><br><span class="line">            searchRecord[node.toString()] = current.getNode();</span><br><span class="line">            searchQueue.put(node, this.heuristics(node, end));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最佳优先搜索的结果可能不是最短路径"><a href="#最佳优先搜索的结果可能不是最短路径" class="headerlink" title="最佳优先搜索的结果可能不是最短路径"></a>最佳优先搜索的结果可能不是最短路径</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/07/07/SearchPath/bfs_wasted_search.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在多个结点cost相同的情况下，上图是优先往上搜索，然而最佳优先搜索只是贪婪的朝目标前进，最后被障碍物挡住，只得向下绕行，所以本算法在存在障碍物的情况下(多数寻路都存在障碍物)，不能够保证是最短路径，想要高效的找到最短路径，就需要试试集各家之所长的A*算法了</p><h2 id="A-搜索"><a href="#A-搜索" class="headerlink" title="A*搜索"></a>A*搜索</h2><p>A*融合了最佳优先搜索和Dijkstra搜索的优点，同时使用节点移动权重和节点离终点的距离，对节点的搜索优先级进行评估<br>有如下公式：</p><p><strong>F(x) = G(x) + H(x)</strong></p><ul><li>F(x)为x节点的搜索权重，权重越小越先被搜索</li><li>G(x)为从起点移动到x节点的cost</li><li>H(x)为从x节点到终点的距离</li></ul><h3 id="核心代码实现-3"><a href="#核心代码实现-3" class="headerlink" title="核心代码实现"></a>核心代码实现</h3><p>我们只需要对最佳搜索算法稍加改造<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let searchQueue: PriorityQueue = new PriorityQueue();</span><br><span class="line">let searchRecord = &#123;&#125;;</span><br><span class="line">let costRecord = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">searchRecord[start.toString()] = true;</span><br><span class="line">costRecord[start.toString()] = 0;</span><br><span class="line">searchQueue.put(start, this.heuristics(start, end) + costRecord[start.toString()]);</span><br><span class="line">while(searchQueue.length)&#123;</span><br><span class="line">    let current = searchQueue.get();</span><br><span class="line">    if(current.getNode().toString() == end.toString())&#123;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    let neighbors = this.getNeighbors(current.getNode());</span><br><span class="line">    for(let node of neighbors)&#123;</span><br><span class="line">        let newCost = node.cost + costRecord[current.getNode().toString()];</span><br><span class="line">        if(costRecord[node.toString()] === undefined)&#123;</span><br><span class="line">            costRecord[node.toString()] = newCost;</span><br><span class="line">            searchRecord[node.toString()] = current.getNode();</span><br><span class="line">            //节点的搜索优先级将由cost和离终点距离决定</span><br><span class="line">            searchQueue.put(node, newCost + this.heuristics(node, end));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="各个算法的对比"><a href="#各个算法的对比" class="headerlink" title="各个算法的对比"></a>各个算法的对比</h3><p><strong>A*算法</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/07/07/SearchPath/Astart1.gif" alt="A*算法" title>                </div>                <div class="image-caption">A*算法</div>            </figure><p><strong>最佳优先算法</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/07/07/SearchPath/Astart_bfs.gif" alt="最佳优先算法" title>                </div>                <div class="image-caption">最佳优先算法</div>            </figure><p><strong>Dijkstra算法</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/07/07/SearchPath/Astart_dijkstra.gif" alt="Dijkstra算法" title>                </div>                <div class="image-caption">Dijkstra算法</div>            </figure><p><strong>广度优先算法</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/07/07/SearchPath/Astart_breadthfs.gif" alt="广度优先算法" title>                </div>                <div class="image-caption">广度优先算法</div>            </figure><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>本文只是简单讲述了一下AStar是怎样演变而来的，使用的Astar算法也是非常原始，现在Astar算法也在不断的变化，出现了很多优化版本，有兴趣深入研究的可以直接在网络上查询</p><blockquote><p>寻路测试demo源码地址：<a href="https://github.com/cdjinwei/SearchPath" target="_blank" rel="noopener">https://github.com/cdjinwei/SearchPath</a></p><p>参考文章：<a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html" target="_blank" rel="noopener">https://www.redblobgames.com/pathfinding/a-star/introduction.html</a></p><p>在线可视寻路工具：<a href="http://qiao.github.io/PathFinding.js/visual/" target="_blank" rel="noopener">http://qiao.github.io/PathFinding.js/visual/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;A-寻路算法&quot;&gt;&lt;a href=&quot;#A-寻路算法&quot; class=&quot;headerlink&quot; title=&quot;A*寻路算法&quot;&gt;&lt;/a&gt;A*寻路算法&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;A*寻路算是游戏开发中很常见的一种寻路算法，网络上相关的介绍也非常多，这次从其他寻
      
    
    </summary>
    
    
      <category term="CocosCreator" scheme="http://yoursite.com/tags/CocosCreator/"/>
    
      <category term="A*" scheme="http://yoursite.com/tags/A/"/>
    
      <category term="寻路算法" scheme="http://yoursite.com/tags/%E5%AF%BB%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    
      <category term="Dijkstra" scheme="http://yoursite.com/tags/Dijkstra/"/>
    
      <category term="广度优先搜索" scheme="http://yoursite.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="最佳优先搜索" scheme="http://yoursite.com/tags/%E6%9C%80%E4%BD%B3%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>CocosCreator资源加载和释放</title>
    <link href="http://yoursite.com/2019/05/29/CocosCreator%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%87%8A%E6%94%BE/"/>
    <id>http://yoursite.com/2019/05/29/CocosCreator资源加载和释放/</id>
    <published>2019-05-29T15:37:06.000Z</published>
    <updated>2019-06-05T16:12:21.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CocosCreator资源加载和释放"><a href="#CocosCreator资源加载和释放" class="headerlink" title="CocosCreator资源加载和释放"></a>CocosCreator资源加载和释放</h2><blockquote><p>CocosCreator的官方文档对资源的加载和释放方面描述的不算清楚, 不少人对游戏内存的把控没有信心,今天我就来捋一捋CocosCreator的资源加载和释放,权当是测试一下各个资源加载和释放的接口</p></blockquote><blockquote><p>本文基于CocosCreator2.1.1</p></blockquote><h3 id="0-CocosCreator的resources目录"><a href="#0-CocosCreator的resources目录" class="headerlink" title="0. CocosCreator的resources目录"></a>0. CocosCreator的resources目录</h3><p>使用过CocosCreator的人应该都知道,resorces目录是用来存放那些需要再游戏中动态加载的资源, 官方稳定建议如果资源不需要动态加载,就不要放在该目录下. 经测试, resources目录下的所有资源在构建工程后生成的setting.js文件中有记录,resources目录下的资源越多也就意味着setting.js越大</p><h3 id="1-CocosCreator的各种类型的资源"><a href="#1-CocosCreator的各种类型的资源" class="headerlink" title="1. CocosCreator的各种类型的资源"></a>1. CocosCreator的各种类型的资源</h3><p>在CocosCreator2.1.1版本中,在空场景的情况下cc.loader._cache中一共有20个对象,下文的资源加载和释放的对比将会刨除这20个对象</p><h5 id="1-cc-Texture2D"><a href="#1-cc-Texture2D" class="headerlink" title="(1) cc.Texture2D"></a>(1) cc.Texture2D</h5><p>这是一个基本的图片资源类型,很多游戏都有这个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//加载一个cc.Texture2D类型的资源</span><br><span class="line">cc.loader.loadRes(&apos;pic&apos;, cc.Texture2D, (err, data) =&gt; &#123;</span><br><span class="line">    if(err) return console.log(err);</span><br><span class="line">    console.log(cc.loader._cache);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>以上代码加载完成之后,_cache中多了一个png资源和一个json资源,其中png资源是图片资源是占用内存的大头, 而json资源则代表着一个cc.Texture2D资源对象.<br>在cache中,cc.Texture2D对象是以json文件的名字作为key保存的,单独释放_cache中的png对象,内存并没有明显下降,图片占用的内存明显没有被释放掉,而单独释放json的结果是png和json都被释放掉了,内存也有明显的下降,所以<strong>加载了那些资源就来,释放时就要完完全全把那些资源释放掉</strong></p><ul><li><p>单独释放png, json文件没有被一起释放,内存也没有明显降低</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc.loader.release(&apos;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.png&apos;);</span><br></pre></td></tr></table></figure></li><li><p>单独释放json, png和json都被释放了,内存有明显下降</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc.loader.release(&apos;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.json&apos;);</span><br></pre></td></tr></table></figure></li></ul><p>那么问题来了,怎样知道加载一个cc.Texture2D时还加载了写什么进来呢?<br>cc.loader.getDependsRecursively()可以获取传入对象的所有依赖资源,参数类型为cc.Asset,cc.RawAsset,或者string</p><blockquote><p><strong>cc.Asset</strong>: 在 Creator 中，所有继承自 cc.Asset 的类型都统称资源，如 cc.Texture2D, cc.SpriteFrame, cc.AnimationClip, cc.Prefab 等。它们的加载是统一并且自动化的，相互依赖的资源能够被自动预加载(2.0版本文档原文)<br><strong>cc.RawAsset</strong>: Creator似乎准备把cc.Asset和cc.RawAsset的标准统一起来,在2.0的文档中没有找到cc.RawAsset的说明,应该已经统一了<br><strong>string</strong>: 这里就是资源的路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cc.loader.loadRes(&apos;image&apos;, cc.Texture2D, (err, data) =&gt; &#123;</span><br><span class="line">    //data 就是一个Texture2D对象</span><br><span class="line">    let deps = cc.loader.getDependsRecursively(data);</span><br><span class="line">    console.log(deps);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//deps的输出, 就是加载image时,所加载的所有资源</span><br><span class="line">[&quot;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.png&quot;,</span><br><span class="line">&quot;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.json&quot;]</span><br><span class="line"></span><br><span class="line">//通过资源的路径也能获取到资源的依赖</span><br><span class="line">//获取到的是</span><br><span class="line">//[&apos;8fdd1c3c-1ec9-4018-b57b-551c9b37eba4&apos;]</span><br><span class="line">let deps = cc.loader.getDependsRecursively(&apos;image&apos;);</span><br><span class="line">//这样也能将加载image时所加载的资源全部释放掉</span><br><span class="line">cc.loader.release(deps);</span><br></pre></td></tr></table></figure></p></blockquote><h5 id="1-cc-SpriteFrame"><a href="#1-cc-SpriteFrame" class="headerlink" title="(1) cc.SpriteFrame"></a>(1) cc.SpriteFrame</h5><p>SpriteFrame类似于一个中间件,夹在Texture2D和Sprite之间,当我们以cc.SpriteFrame类型进行资源加载时,我们会得到一个SpriteFrame对象,而通过SpriteFrame对象,我们能够获取到3个依赖资源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cc.loader.loadRes(&apos;image&apos;, cc.SpriteFrame, (err, data) =&gt; &#123;</span><br><span class="line">    //data 就是一个SpriteFrame对象</span><br><span class="line">    let desp = cc.loader.getDependsRecursively(data);</span><br><span class="line">    console.log(desp);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//desp的输出, 就是加载image时,所加载的所有资源</span><br><span class="line">[&quot;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.png&quot;,</span><br><span class="line">&quot;res/import/8f/8fdd1c3c-1ec9-4018-b57b-551c9b37eba4.json&quot;,</span><br><span class="line">res/import/3e/3e24d7c4-3041-4acd-bc91-378df4a24e5f.json]</span><br></pre></td></tr></table></figure></p><p>前两个资源是我们以cc.Texture2D类型进行加载得到的,第三个资源就代表着我们的SpriteFrame对象,这个SpriteFrame对象在_cache中,就是以这个json文件的名字作为key进行保存的</p><p>在释放以Texture2D类型加载进来的资源时, cc.loader.release(‘image’)能够轻松将加载进来的资源释放掉,而想要释放以SpriteFrame类型加载进来的资源,这么简单的处理将会坑到自己<br>那是因为<strong>从资源路径获取到的依赖资源不包含SpriteFrame</strong>, 如果这样鲁莽释放,加载进来的SpriteFrame就残留在了cache中,当我们再次以SpriteFrame类型加载这个资源时,<strong>由于cache中残留的SpriteFrame对象,loader将不会加载资源,而是直接返回了cache中这个已经丢失了Texture2D的SpriteFrame</strong>,我们此时可以在控制台中看到一大片的webgl的警告</p><h3 id="2-如何优雅地释放资源"><a href="#2-如何优雅地释放资源" class="headerlink" title="2. 如何优雅地释放资源"></a>2. 如何优雅地释放资源</h3><h5 id="资源引用计数"><a href="#资源引用计数" class="headerlink" title="资源引用计数"></a>资源引用计数</h5><p>对于释放动态加载的资源,有些人的做法是在加载时获取到加载资源的完整依赖进行累加计数,在释放时对对应资源减一,引用为0时进行真正的释放</p><h5 id="资源份文件夹管理"><a href="#资源份文件夹管理" class="headerlink" title="资源份文件夹管理"></a>资源份文件夹管理</h5><p>另一种做法是把各个界面和场景自己才会用到的资源分文件夹管理,然后通用资源用另一个文件夹管理,在游戏离开某个界面进入另一个界面时,将除通用资源以外的资源统统释放掉</p><blockquote><p>我个人目前还是跟喜欢后一种做法,一个原因是自己没有一个好的引用计数的实现,另一个原因是经常用到的资源可能会时不时被释放掉,而再次加载有需要一定的时间,会造成不好的体验,就使用了后一种做法</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CocosCreator资源加载和释放&quot;&gt;&lt;a href=&quot;#CocosCreator资源加载和释放&quot; class=&quot;headerlink&quot; title=&quot;CocosCreator资源加载和释放&quot;&gt;&lt;/a&gt;CocosCreator资源加载和释放&lt;/h2&gt;&lt;bloc
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CocosCreatorWeb调试模拟IphoneX</title>
    <link href="http://yoursite.com/2019/03/19/CocosCreatorWeb%E8%B0%83%E8%AF%95%E6%A8%A1%E6%8B%9FIphoneX/"/>
    <id>http://yoursite.com/2019/03/19/CocosCreatorWeb调试模拟IphoneX/</id>
    <published>2019-03-19T14:09:11.000Z</published>
    <updated>2019-03-19T14:50:43.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CocosCreatorWeb调试模拟IphoneX"><a href="#CocosCreatorWeb调试模拟IphoneX" class="headerlink" title="CocosCreatorWeb调试模拟IphoneX"></a>CocosCreatorWeb调试模拟IphoneX</h1><p>CocosCreator的web调试工具，默认提供了模拟多种设备分辨率的选项，但通常开发者都会有特殊的适配需求(适配iphonex等刘海屏)，CocosCreator并没有涵盖到也很难涵盖到各种分辨率，不过开发者可以自行添加<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/19/CocosCreatorWeb调试模拟IphoneX/cocos_web_simulator_2019-03-19_22-01-38.png" alt="CocosCreator默认提供的选项" title>                </div>                <div class="image-caption">CocosCreator默认提供的选项</div>            </figure></p><h2 id="设置自定义分辨率"><a href="#设置自定义分辨率" class="headerlink" title="设置自定义分辨率"></a>设置自定义分辨率</h2><p>在CocosCreator\resources\static\preview-templates下的boot.js中有分辨率模拟选项的配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// init device resolutions</span><br><span class="line">    var devices = [</span><br><span class="line">        &#123; name: &apos;Apple iPad&apos;, width: 1024, height: 768, ratio: 2 &#125;,</span><br><span class="line">        &#123; name: &apos;Apple iPad Mini&apos;, width: 1024, height: 768, ratio: 1 &#125;,</span><br><span class="line">        &#123; name: &apos;Apple iPhone 4&apos;, width: 320, height: 480, ratio: 2 &#125;,</span><br><span class="line">        &#123; name: &apos;Apple iPhone 5&apos;, width: 320, height: 568, ratio: 2 &#125;,</span><br><span class="line">        &#123; name: &apos;Apple iPhone 6&apos;, width: 375, height: 667, ratio: 2 &#125;,</span><br><span class="line">        &#123; name: &apos;Apple iPhone 6 Plus&apos;, width: 414, height: 736, ratio: 3 &#125;,</span><br><span class="line">        &#123; name: &apos;Huawei P9&apos;, width: 540, height: 960, ratio: 2&#125;,</span><br><span class="line">        &#123; name: &apos;Huawei Mate9 Pro&apos;, width: 720, height: 1280, ratio: 2&#125;,</span><br><span class="line">        &#123; name: &apos;Goolge Nexus 4&apos;, width: 384, height: 640, ratio: 2 &#125;,</span><br><span class="line">        &#123; name: &apos;Goolge Nexus 5&apos;, width: 360, height: 640, ratio: 3 &#125;,</span><br><span class="line">        &#123; name: &apos;Goolge Nexus 6&apos;, width: 412, height: 732, ratio: 3.5 &#125;,</span><br><span class="line">        &#123; name: &apos;Goolge Nexus 7&apos;, width: 960, height: 600, ratio: 2 &#125;,</span><br><span class="line">        &#123; name: &apos;Iphone X&apos;, width: 375, height: 812, ratio: 3 &#125;,</span><br><span class="line">    ];</span><br></pre></td></tr></table></figure></p><p>只需要按照已有的格式添加就可以了</p><ul><li>name：模拟器选项中展示的名字</li><li>width：模拟器在网页上实际的宽度</li><li>height：模拟器在网页上实际的高度</li><li>ratio：字面意思是缩放比例，但是修改过后没有产生效果？<br>我在devices中加入了iphonex的分辨率信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; name: &apos;Iphone X&apos;, width: 1125, height: 2436, ratio: 1 &#125;</span><br></pre></td></tr></table></figure></li></ul><p>预览后发现游戏画面已经超过了浏览器窗口的大小，出现了滑动条，所以将宽高缩小3倍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; name: &apos;Iphone X&apos;, width: 375, height: 812, ratio: 3 &#125;,</span><br></pre></td></tr></table></figure></p><p>刷新页面得到了能够正常预览的大小<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/2019/03/19/CocosCreatorWeb调试模拟IphoneX/iphonex_2019-03-19_22-45-44.png" alt="IphoneXWeb模拟器" title>                </div>                <div class="image-caption">IphoneXWeb模拟器</div>            </figure></p><blockquote><p>虽然web模拟器调试非常便利，但是适配IphoneX还是要以实机效果为准</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CocosCreatorWeb调试模拟IphoneX&quot;&gt;&lt;a href=&quot;#CocosCreatorWeb调试模拟IphoneX&quot; class=&quot;headerlink&quot; title=&quot;CocosCreatorWeb调试模拟IphoneX&quot;&gt;&lt;/a&gt;CocosCre
      
    
    </summary>
    
    
      <category term="CocosCreator" scheme="http://yoursite.com/tags/CocosCreator/"/>
    
  </entry>
  
  <entry>
    <title>GooglePlay会对apk重新签名</title>
    <link href="http://yoursite.com/2019/03/10/GooglePlay%E4%BC%9A%E5%AF%B9apk%E9%87%8D%E6%96%B0%E7%AD%BE%E5%90%8D/"/>
    <id>http://yoursite.com/2019/03/10/GooglePlay会对apk重新签名/</id>
    <published>2019-03-10T08:17:24.000Z</published>
    <updated>2019-03-10T08:18:09.834Z</updated>
    
    <content type="html"><![CDATA[<h2 id="上传到GooglePlay的Apk会被重新签名"><a href="#上传到GooglePlay的Apk会被重新签名" class="headerlink" title="上传到GooglePlay的Apk会被重新签名"></a>上传到GooglePlay的Apk会被重新签名</h2><p>最近在准备发布新版本的时候,测试同学发现新版本的apk覆盖老版本的时候安装失败了,通过命令行安装发现问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failure [INSTALL_FAILED_UPDATE_INCOMPATIBLE: Package your.package.name signatures do not match the previously installed version; ignoring!]</span><br></pre></td></tr></table></figure><p>意思是两个版本的Apk签名不同,新版本的Apk能够确定是用release签名打包的,难道老版本的包是用了debug的签名吗?,经过排查老版本的包也是用的release签名,打包配置也都是同一套配置.</p><p>最后问题指向GooglePlay,应该是上传到GooglePlay后,被重新签名了,我将从googleplay下载的包卸载掉,安装本地的低版本,然后用高版本覆盖安装,果然没有问题,应该就是googleplay重新签名了,最后上传新包到googleplay成功上传,验证了猜想(因为签名如果不一致是不能上传成功的),最后发布更新可以正常更新</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;上传到GooglePlay的Apk会被重新签名&quot;&gt;&lt;a href=&quot;#上传到GooglePlay的Apk会被重新签名&quot; class=&quot;headerlink&quot; title=&quot;上传到GooglePlay的Apk会被重新签名&quot;&gt;&lt;/a&gt;上传到GooglePlay的Apk
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="GooglePlay" scheme="http://yoursite.com/tags/GooglePlay/"/>
    
      <category term="apk签名" scheme="http://yoursite.com/tags/apk%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android应用发布到GooglePlay</title>
    <link href="http://yoursite.com/2019/03/10/AndroidPublishToGooglePlay/"/>
    <id>http://yoursite.com/2019/03/10/AndroidPublishToGooglePlay/</id>
    <published>2019-03-10T07:42:37.000Z</published>
    <updated>2019-03-19T14:05:02.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-app发布到GooglePlay"><a href="#Android-app发布到GooglePlay" class="headerlink" title="Android app发布到GooglePlay"></a>Android app发布到GooglePlay</h1><p>开头的废话: 最近使用cocoscreator开发的一个游戏的android版本需要发布到google play, 要上传到google play就需要再app中集成google play service, 以前本来接入过,接入过程非常简单,也有发布到google play的应用,结果时间长了居然给忘掉了,google了一下才配置好,所以索性将它记录下来,以免再忘</p><blockquote><p>本文使用的是AndroidStudio的工程进行开发,文章也只是大致讲述在发布到googleplay上,程序配置上需要进行的工作</p></blockquote><hr><h3 id="1-配置build-gradle"><a href="#1-配置build-gradle" class="headerlink" title="1. 配置build.gradle"></a>1. 配置build.gradle</h3><p>在app level下的build.gradle文件中加入google play service的依赖,不配置的话步骤2中的google_play_services_version就找不到定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation &apos;com.google.android.gms:play-services:12.0.1&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-配置AndroidManifest-xml"><a href="#2-配置AndroidManifest-xml" class="headerlink" title="2. 配置AndroidManifest.xml"></a>2. 配置AndroidManifest.xml</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- google play --&gt;</span><br><span class="line">&lt;meta-data android:name=&quot;com.google.android.gms.version&quot; android:value=&quot;@integer/google_play_services_version&quot; /&gt;</span><br></pre></td></tr></table></figure><p>google_play_services_version不需要自己定义,它由google play service定义,它的值也随着google play service的版本变化而变化</p><blockquote><p>上传apk至google play 必须加入这个配置,否则不能成功上传</p></blockquote><p>配置到这里,就已经能够上传到google play了</p><h3 id="3-跳转至GooglePlay商店"><a href="#3-跳转至GooglePlay商店" class="headerlink" title="3.跳转至GooglePlay商店"></a>3.跳转至GooglePlay商店</h3><p>app一般都有个引导评论的功能,android的app一般直接跳转到GooglePlay商店详情页面,用户可以在这里给app打分和评论,附上代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void launchAppDetail() &#123;</span><br><span class="line">    final String GOOGLE_PLAY = &quot;com.android.vending&quot;;//这里对应的是谷歌商店，跳转别的商店改成对应的即可</span><br><span class="line">    try &#123;</span><br><span class="line">        Uri uri = Uri.parse(&quot;market://details?id=&quot; + mActivity.getPackageName());</span><br><span class="line">        Intent intent = new Intent(Intent.ACTION_VIEW, uri);</span><br><span class="line">        intent.setPackage(GOOGLE_PLAY);</span><br><span class="line">        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">        mActivity.startActivity(intent);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        mActivity.runOnUiThread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Toast.makeText(mActivity, &quot;GooglePlay Store not exist&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android-app发布到GooglePlay&quot;&gt;&lt;a href=&quot;#Android-app发布到GooglePlay&quot; class=&quot;headerlink&quot; title=&quot;Android app发布到GooglePlay&quot;&gt;&lt;/a&gt;Android app发布到
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="GooglePlay" scheme="http://yoursite.com/tags/GooglePlay/"/>
    
  </entry>
  
  <entry>
    <title>Android工程集成Admob</title>
    <link href="http://yoursite.com/2019/03/10/AndroidIntegrateAdmob/"/>
    <id>http://yoursite.com/2019/03/10/AndroidIntegrateAdmob/</id>
    <published>2019-03-10T06:14:36.000Z</published>
    <updated>2019-03-19T14:04:46.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AndroidStudio集成Admob"><a href="#AndroidStudio集成Admob" class="headerlink" title="AndroidStudio集成Admob"></a>AndroidStudio集成Admob</h1><p>前段时间公司的游戏开发的差不多了，集成了一些SDK，本次要说的就是其中之一的Admob，这个变现sdk就不用介绍了吧，看到这个文章的肯定都知道是什么，实在不清楚就去玩玩度娘。其实Android应用接入Admob没什么复杂的地方，只不过手上这个应用是CocosCreator开发的游戏，就是在一个Activity上面加了个GLView，然后渲染，要接入SDK需要稍微绕一点点弯路，然后国内的网络环境也堪忧，有可能会在测试的时候带来麻烦。</p><h3 id="Android-GL线程与UI线程通信"><a href="#Android-GL线程与UI线程通信" class="headerlink" title="Android GL线程与UI线程通信"></a>Android GL线程与UI线程通信</h3><p>熟悉Cocos的同学都知道，我们的游戏都是在一个GLview上进行的，游戏开发的语言是js，要想与UI线程通信，就需要引擎提供的api<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jsb.reflection.callStaticMethod(&apos;类路径&apos;, &apos;方法名&apos;, &apos;参数签名&apos;, &apos;参数列表&apos;);</span><br></pre></td></tr></table></figure></p><p>只有静态方法可以通过这个方式进行调用，关于这个方法的详细说明就不过多赘述，官方文档有很详细的讲解<a href="http://docs.cocos.com/creator/manual/zh/advanced-topics/java-reflection.html" target="_blank" rel="noopener"> [ 传送门 ]</a>。</p><h3 id="接入Admob依赖库"><a href="#接入Admob依赖库" class="headerlink" title="接入Admob依赖库"></a>接入Admob依赖库</h3><p>首先在工程级的build.gradle中添加依赖(最外层的那个build.gralde文件)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123;</span><br><span class="line">            url &quot;https://maven.google.com&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再在app级的build.gradle中添加相关库的依赖(定义了applicationid等应用信息的那个build.gradle)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">//new dependence</span><br><span class="line">    implementation &apos;com.google.android.gms:play-services-ads:15.0.0&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里库的配置就弄完了，可以开始撸代码了</p><blockquote><p>注意，Admob要求的Target Android API level 最低是14，不然编译阶段会提示你修改</p></blockquote><h3 id="接入Banner广告"><a href="#接入Banner广告" class="headerlink" title="接入Banner广告"></a>接入Banner广告</h3><p>Banner广告就是一个显示在屏幕某个位置的横幅广告，难以避免地会占用游戏节目，是个很不友好的广告，在Android原生应用中，可以直接在要植入广告的界面的xml布局里面直接把banner广告布局填进去，适配也非常的简单，但是我这游戏就不行，cocos的长度单位与Android的不一样，需要经过一些换算才能得到正确的大小，Banner广告展示的大小，SDK有提供了很多尺寸的选择，其中Smart Banner是SDK自己进行适配，如果广告内容把游戏内容遮挡了，这肯定是非常不好的，所以我非常咸鱼的选择了最小的尺寸(快速迭代嘛，以后再优化 &gt;_&lt; )，下面直接贴代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//首先初始化Admob mActivity就是游戏的主Activity，admob相关的id找让你接sdk的人要，嘻嘻</span><br><span class="line">MobileAds.initialize(mActivity,mActivity.getResources().getString(R.string.admob_appid));</span><br><span class="line"></span><br><span class="line">mActivity.runOnUiThread(new Runnable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               bannerAd = new AdView(mActivity);</span><br><span class="line">               bannerAd.setAdUnitId(mActivity.getResources().getString(R.string.admob_banner_id));</span><br><span class="line">               bannerAd.setAdSize(AdSize.BANNER);</span><br><span class="line">               bannerAd.setAdListener(bannerAdListener);</span><br><span class="line">               </span><br><span class="line">               AdRequest adRequest = new AdRequest.Builder()</span><br><span class="line">                       .addTestDevice(&quot;test_device_id&quot;)</span><br><span class="line">                       .build();</span><br><span class="line">               bannerAd.loadAd(adRequest);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">    public static AdListener bannerAdListener = new AdListener()&#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void onAdLoaded() &#123;</span><br><span class="line">           mActivity.runOnUiThread(new Runnable() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void run() &#123;</span><br><span class="line">                   if(bannerAd.getParent() == null)&#123;</span><br><span class="line">                       FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT);</span><br><span class="line">                       params.gravity = Gravity.BOTTOM;</span><br><span class="line">                       mActivity.addContentView(bannerAd, params);</span><br><span class="line">                   &#125;else&#123;  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void onAdFailedToLoad(final int errorCode) &#123; &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void onAdOpened() &#123; &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void onAdLeftApplication() &#123;  &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void onAdClosed() &#123; &#125;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure></p><p>由于我们不能直接在GL thread去修改UI thread，所以我们这里用了个runOnUIthread包装了一下，也可以用其他方式去实现<br>bannerAd.setAdListener(bannerAdListener) 是广告的生命周期的监听函数，广告的状态发生变化都会再这里得到通知，我这里在广告Load成功后对banner广告的UI进行了操作，如果Banner没有添加到Activity中就把它添加进去，并且把它放到了屏幕最底部，之所以加判断是因为Banner是会自己进行一定频率的刷新，如果每次Load成功都去添加一个到场景，老板知道了就要开除我了</p><h3 id="接入插屏广告"><a href="#接入插屏广告" class="headerlink" title="接入插屏广告"></a>接入插屏广告</h3><p>插屏广告·是一种完全覆盖游戏的广告，需要用户手动点击关闭按钮才会消失，这个的接入相比Banner就简单点了，由于产品要求要确保广告在某个时间点弹出来，所以插屏这里我预先进行了Load操作，然后在要展示的时候才show它，因为加载插屏是有一定的延迟的，如果广告内容是视频的话，延迟就更明显了，还是贴上代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//加载插屏广告</span><br><span class="line">mActivity.runOnUiThread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Log.e(DEBUG_TAG,&quot;loadInterstitial&quot;);</span><br><span class="line">                AdRequest request = new AdRequest.Builder()</span><br><span class="line">                        .addTestDevice(&quot;test_device_id&quot;)</span><br><span class="line">                        .build();</span><br><span class="line">                interstitialAd.setAdListener(interstitialAdListener);</span><br><span class="line">                interstitialAd.loadAd(request);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">//展示插屏广告</span><br><span class="line">//一定要确保在UI线程操作</span><br><span class="line">        mActivity.runOnUiThread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                if(interstitialAd.isLoaded())&#123;</span><br><span class="line">                    interstitialAd.show();</span><br><span class="line">                &#125;else if(interstitialAd.isLoading())&#123;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                //如果没有loading，或者load失败了就进行load</span><br><span class="line">                    loadInterstitial(curInterstitialAdPos);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        public static AdListener interstitialAdListener = new AdListener()&#123;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="接入视频广告"><a href="#接入视频广告" class="headerlink" title="接入视频广告"></a>接入视频广告</h3><p>视频广告的接入和插屏几乎一样，非常简单，这次需要用到广告的回掉，因为这涉及到观看广告的奖励的发放,<br> talk is cheap, show me the code~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//load</span><br><span class="line">        mActivity.runOnUiThread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                AdRequest adRequest = new AdRequest.Builder().build();</span><br><span class="line">                rewardedVideoAd.loadAd(mActivity.getResources().getString(R.string.admob_rewardedvideo_id),adRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">//show</span><br><span class="line">mActivity.runOnUiThread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                if(rewardedVideoAd.isLoaded())&#123;</span><br><span class="line">                    rewardedVideoAd.show();</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    loadRewardedVideo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">//广告回掉</span><br><span class="line">//收到这个回掉表示用户完整观看了视频广告，需要发放奖励</span><br><span class="line">    @Override</span><br><span class="line">    public void onRewarded(RewardItem rewardItem) &#123;</span><br><span class="line">        Log.e(DEBUG_TAG,&quot;onRewarded&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Always test with test ads !</p><blockquote><p>进行测试的时候尽量使用文档提供的测试id，一来可以排除掉市场人员app广告信息配置错误，二来这也是官方要求的(不要刷广告)，其实刷也没用，刷着刷着就不给你展示广告了</p></blockquote><hr><p>我为什么突然没广告看了！</p><blockquote><p>先别急，这一般不是我们程序员的问题(先甩锅),广告没有按预期播放一般有4个原因：<br>1.INTERNAL_ERROR(内部错误) 2.INVALID_REQUEST(非法请求) 3.NETWORK_ERROR(网络错误) 4.NOT_FILL(未填充)<br>所以测试的时候最好能把这些信息实时的输出出来，以便在没能成功展示广告时看到是什么原因（=_=）</p></blockquote><p>有了AndroidStudio，接入广告真的简单了好多，其实还有原生广告和中介还么有说到，原生广告真的是非常的坑爹，这里简单说下中介，通过中介我们可以去接入一些其他的广告来源，目前文章中就能得到来自Admob的广告，通过一些配置就可以得到来自其他广告联盟的广告了，这两个就下次再写一篇讲讲</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AndroidStudio集成Admob&quot;&gt;&lt;a href=&quot;#AndroidStudio集成Admob&quot; class=&quot;headerlink&quot; title=&quot;AndroidStudio集成Admob&quot;&gt;&lt;/a&gt;AndroidStudio集成Admob&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="CocosCreator" scheme="http://yoursite.com/tags/CocosCreator/"/>
    
      <category term="Admob" scheme="http://yoursite.com/tags/Admob/"/>
    
  </entry>
  
</feed>
